<!DOCTYPE html>
<html lang="cn">
<head>
  <meta charset="UTF-8">
  <title>Solar System</title>
  <link rel="icon" href="https://cdn.jsdelivr.net/gh/isXSong/FigureBed/SolarSystem/icon.png" type="image/x-icon">
  <link rel="stylesheet" href="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/font-awesome/4.7.0/css/font-awesome.min.css">
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <!------ 标题 ------>
  <div id="title">
    <img src="https://cdn.picui.cn/vip/2025/07/11/6870e6590199f.png" alt="Solar System">
    <h1>Solar System Sim</h1>
  </div>

  <!------ 仪表盘区域 ------>
  <div id="dashboard">
    <div class="dashboard-item">
      <span class="db-label">速度比例</span>
      <span class="db-value" id="db-speed">1d/s</span>
    </div>
    <div class="dashboard-divider"></div>
    <div class="dashboard-item">
      <span class="db-label">沙罗周期进度</span>
      <span class="db-value" id="db-saros">0%</span>
    </div>
    <div class="dashboard-divider"></div>
    <div class="dashboard-item">
      <span class="db-label">月相状态</span>
      <span class="db-value" id="db-moonphase">新月</span>
    </div>
    <div class="dashboard-divider"></div>
    <div class="dashboard-item">
      <span class="db-label">对齐程度</span>
      <span class="db-value" id="db-alignment">0%</span>
    </div>
  </div>

  <!------ 控制面板 ------>
  <button id="controlBtn" aria-label="打开/关闭控制面板">
    <span>≡</span>
  </button>
  <aside id="controlPanel">
    <!---- 标签页切换导航 ---->
    <nav id="tabs">
      <button class="tab active" data-tab="page1">
        <i class="fa fa-info-circle"></i>
        <span>信息</span>
      </button>
      <button class="tab" data-tab="page2">
        <i class="fa fa-eye"></i>
        <span>视图</span>
      </button>
      <button class="tab" data-tab="page3">
        <i class="fa fa-cog"></i>
        <span>参数</span>
      </button>
    </nav>
    <!---- 标签页内容 ---->
    <div id="panels">
      <!-- 标签页1：信息页 -->
      <div class="panel active" id="page1">
        <div class="contorl-block" id="infoBlock">
          <div id="infoBody">
            <h4>&emsp;欢迎使用Solar System Sim!<br>这是一个在线天体运行演示平台</h4>
            <img src="https://cdn.jsdelivr.net/gh/isXSong/FigureBed/SolarSystem/introduce.png" width="90%">
            <p>&emsp;&emsp;本项目旨在通过交互式模拟，直观呈现太阳、地球、月球的运行关系，以及由此产生的月相变化、日食和月食现象。核心功能包括：
            <ul>
              <li>- 实时模拟日月地相对运动轨迹；</li>
              <li>- 交互式的3D自由视角观察；</li>
              <li>- 动态展示不同时间点的月相；</li>
              <li>- 预测和演示日食（日全食、日偏食、日环食）和月食（月全食、月偏食）的发生过程；</li>
              <li>- 支持调整时间流速、观测视角等参数。</li>
            </ul>
            </p>
            <p>更多使用信息请查看<a href="javascript:void(0)" onclick="clickOnToolHelp()">帮助手册</a></p>
          </div>
          <div id="infoFooter">
            <p>- © 2025 Solar System Sim. All rights reserved. -</p>
            <p>- Developed by OneSony,&ensp;isXSong,&ensp;VoinCiao. -</p>
            <p>- Powered by Three.js -</p>
            <p>
              本项目仅用于学习和教学实践&ensp;|&ensp;
              <a href="https://github.com/OneSony/SolarSystem" target="_blank">GitHub 项目仓库</a>
            </p>
          </div>
        </div>
      </div>
      <!-- 标签页2：视图页 -->
      <div class="panel" id="page2">
        <!-- 控制块：相机视角 -->
        <div class="contorl-block" id="viewSettings">
          <h4>
            <span class="zh">相机视角</span>
            <span class="en">Camera View</span>
          </h4>
          <ul>
            <li>
              <input type="radio" name="view" id="top-view" value="top-view" hidden>
              <label for="top-view" class="view-label">
                <i class="fa fa-toggle-down"></i>
                <span>俯视图</span>
              </label>
            </li>
            <li>
              <input type="radio" name="view" id="side-view" value="side-view" hidden>
              <label for="side-view" class="view-label">
                <i class="fa fa-toggle-right"></i>
                <span>侧视图</span>
              </label>
            </li>
            <li>
              <input type="radio" name="view" id="3D-view" value="3D-view" checked hidden>
              <label for="3D-view" class="view-label">
                <i class="fa fa-cube"></i>
                <span>3D视图</span>
              </label>
            </li>
          </ul>
        </div>
        <hr>
        <!-- 控制块：贴图纹理 -->
        <div class="contorl-block" id="textureSettings">
          <h4>
            <span class="zh">贴图纹理</span>
            <span class="en">Surface Texture</span>
          </h4>
          <div id="earthTexture">
            <h5>地球贴图</h5>
            <ul>
              <li>
                <input type="radio" name="earth-texture" id="solid-blue" value="solid-blue" hidden>
                <label for="solid-blue" class="texture-label">
                  <i></i>
                  <span>纯蓝色</span>
                </label>
              </li>
              <li>
                <input type="radio" name="earth-texture" id="common-map" value="common-map" hidden>
                <label for="common-map" class="texture-label">
                  <i></i>
                  <span>世界区划地图</span>
                </label>
              </li>
              <li>
                <input type="radio" name="earth-texture" id="satellite-map" value="satellite-map" checked hidden>
                <label for="satellite-map" class="texture-label">
                  <i></i>
                  <span>卫星地图</span>
                </label>
              </li>
            </ul>
          </div>
          <div id="sunTexture">
            <h5>太阳贴图</h5>
            <ul>
              <li>
                <input type="radio" name="sun-texture" id="solid-orange" value="solid-orange" hidden>
                <label for="solid-orange" class="texture-label">
                  <i></i>
                  <span>纯橙色</span>
                </label>
              </li>
              <li>
                <input type="radio" name="sun-texture" id="true-surface" value="true-surface" checked hidden>
                <label for="true-surface" class="texture-label">
                  <i></i>
                  <span>真实表面</span>
                </label>
              </li>
            </ul>
          </div>
          <div id="starland">
            <h5>星空背景</h5>
            <ul>
              <li>
                <input type="radio" name="starland" id="solid-black" value="solid-black" hidden>
                <label for="solid-black" class="texture-label">
                  <i></i>
                  <span>纯黑</span>
                </label>
              </li>
              <li>
                <input type="radio" name="starland" id="stars" value="stars" checked hidden>
                <label for="stars" class="texture-label">
                  <i></i>
                  <span>繁星</span>
                </label>
              </li>
            </ul>
          </div>
        </div>
        <hr>
        <div class="contorl-block" id="auxiliarySettings">
          <h4>
            <span class="zh">辅助显示</span>
            <span class="en">Auxiliary Information</span>
          </h4>
          <ul>
            <li>
              <input type="checkbox" id="axisSwitch" checked hidden>
              <label for="axisSwitch" class="texture-label">
                <span>显示地轴</span>
                <i><span>√</span></i>
              </label>
            </li>
            <li>
              <input type="checkbox" id="moonNormalSwitch" checked hidden>
              <label for="moonNormalSwitch" class="texture-label">
                <span>显示轨道法向量</span>
                <i><span>√</span></i>
              </label>
            </li>
            <li>
                <input type="checkbox" id="moonNodesSwitch" checked hidden>
                <label for="moonNodesSwitch" class="texture-label">
                  <span>显示黄白交点</span>
                  <i><span>√</span></i>
                </label>
            </li>
          </ul>
        </div>
        <hr>
        <!-- 控制块：日月食画中画 -->
        <div class="contorl-block" id="PIPSettings">
          <h4>
            <span class="zh">日月食画中画</span>
            <span class="en">Solar/Moon Eclipse PIP</span>
          </h4>
          <ul><li>
            <input type="checkbox" id="PIPSwitch" hidden>
            <label for="PIPSwitch" class="PIP-label">
              <h5>画中画开关</h5>
              <i></i>
            </label>
          </li></ul>
        </div>
      </div>
      <!-- 标签页3：参数调整 -->
      <div class="panel" id="page3">
        <!-- 控制块：速度控制 -->
        <div class="contorl-block" id="speedSettings">
          <h4>
            <span class="zh">速度控制</span>
            <span class="en">Speed Control</span>
          </h4>
          <ul><li>
            <h5>速度调节</h5>
            <input type="range" id="speedInput" min="-7" max="7" step="1" value="1">
            <label for="speedInput" class="speed-label" id="speedLabel">x1</label>
          </li></ul>
          <ul>
            <li>
              <h5>运动反向</h5>
              <input type="checkbox" id="reserveSwitch" hidden>
              <label for="reserveSwitch">
                <i></i>
              </label>
            </li>
            <li>
              <h5>运动暂停</h5>
              <input type="checkbox" id="stopSwitch" hidden>
              <label for="stopSwitch">
                <i></i>
              </label>
            </li>
          </ul>
        </div>
        <hr>
        <!-- 控制块：时间控制 -->
        <div class="contorl-block" id="timeSettings">
          <h4>
            <span class="zh">快捷跳转</span>
            <span class="en">Quick Jump</span>
          </h4>
          <ul>
            <li>
              <button id="oneYearAgo" onclick="dateJumpBy(-365)">-1年</button>
              <button id="oneMonthAgo" onclick="dateJumpBy(-30)">-1月</button>
              <button id="oneMonthForward" onclick="dateJumpBy(30)">+1月</button>
              <button id="oneYearForward" onclick="dateJumpBy(365)">+1年</button>
            </li>
            <li>
              <button id="nextSolarEclipse">下一次日食</button>
              <button id="nextLunarEclipse">下一次月食</button>
            </li>
            <li>
              <button id="nextTotalSolarEclipse">下一次日全食</button>
              <button id="nextTotalLunarEclipse">下一次月全食</button>
            </li>
            <li>
              <button id="nextPartialSolarEclipse">下一次日偏食</button>
              <button id="nextPartialLunarEclipse">下一次月偏食</button>
            </li>
          </ul>
        </div>
      </div>
    </div>
  </aside>

  <!------ 画中画UI框 ------>
  <div id="pipContainer" style="display: none;">
    <div id="pipHeader">
      <div class="pip-title">
        <i class="fa fa-video-camera"></i>
        <span>日月食观测</span>
      </div>
      <div class="pip-controls">
        <button class="pip-btn" id="pipMinimize" title="最小化">
          <i class="fa fa-minus"></i>
        </button>
        <button class="pip-btn" id="pipClose" title="关闭">
          <i class="fa fa-times"></i>
        </button>
      </div>
    </div>
    <div id="pipContent">
      <div id="pipCanvas">
        <!-- 3D月相渲染容器 -->
        <div id="moonPhase3D"></div>
      </div>
      <div id="pipInfo">
        <div class="pip-moon-distance">
          <span class="distance-label">月球距离</span>
          <select id="pipMoonDistanceSelect">
            <option value="perigee">近地点 (易全食)</option>
            <option value="average" selected>平均距离</option>
            <option value="apogee">远地点 (易环食)</option>
          </select>
        </div>
      </div>
    </div>
  </div>

  <!------ 小工具条 ------>
  <nav id="toolBar">
    <button class="tool-btn" id="toolPause" title="暂停" onclick="clickOnToolPause()">
      <i class="fa fa-pause"></i>
    </button>
    <button class="tool-btn" id="toolSpeed" title="速度" onclick="clickOnToolSpeed()">
      <i>x1</i>
    </button>
    <hr>
    <button class="tool-btn" id="toolView" title="切换视角" onclick="clickOnToolView()">
      <i class="fa fa-eye"></i>
    </button>
    <button class="tool-btn" id="toolScreenshot" title="截图" onclick="clickOnToolScreenshot()">
      <i class="fa fa-camera"></i>
    </button>
    <hr>
    <button class="tool-btn" id="toolHelp" title="帮助" onclick="clickOnToolHelp()">
      <i class="fa fa-question"></i>
    </button>
  </nav>

  <div id="modalMask" class="modal">
    <div id="helpWindow">
      <span id="closeWindowBtn" onclick="closeHelpWindow()">&times;</span>
      <div id="helpBody">
        <button id="prevPageBtn">&#60;</button>
        <div id="pagesContainer">
        <!-- 每一页内容单独一个div -->
          <ul id="helpPages">
            <li id="helpPage0" class="helpPage">
              <h2>帮助文档</h2>
              <div class="helpContent"> 
                <p><strong>欢迎来到 “Solar System Sim” 网页</strong>！</p>
                <p>这是一个基于 Three.js 库打造的日月地运动与日食、月食在线模拟演示工具.</p>
                <p>
                  本工具旨在为用户提供一个直观易用的平台，以 3D 视角动态地观察：<br>
                  &emsp;- 地球、月球和太阳之间的运行轨迹;<br>
                  &emsp;- 天体的自转、公转、轨道进动等动态关系;<br>
                  &emsp;- 日食、月食等天象的周期变化.
                </p>
                <p>页面提供了尽可能全面的功能和简便易用的操作方式，以期让用户更好的专注于探索和理解天文现象。下面是一个关于如何使用该网页的简要指南</p>
              </div>
            </li>
            <li id="helpPage1" class="helpPage">
              <h2>界面</h2>
              <div class="helpContent">
                <p>Solar System Sim 网页界面主要包含以下部分：</p>
                <ul>
                  <li><strong>显示区：</strong>是主要的可视化场景，展现地球、月球和太阳的相对运动及相关天象；</li>
                  <li><strong>控制面板：</strong>页面左侧边栏，通过按钮呼出或隐藏，提供了基本信息、视图切换、参数调整、辅助工具等内容;</li>
                  <li><strong>小工具条：</strong>悬浮于页面右下角，集合暂停、速度调节、视角切换、截图、帮助等常用功能；</li>
                  <li><strong>仪表盘：</strong>位于页面右上角，实时显示当前日期、速度和天象进程等状态，帮助用户把握模拟进程与关键数据;</li>
                  <li><strong>画中画框：</strong>通过控制面板打开，更详细的展示日月食等天象的2D细节.</li>
                </ul>
             </div>
            </li>
            <li id="helpPage2" class="helpPage">
              <h2>视角控制</h2>
              <div class="helpContent">
                <p>Solar System Sim 支持三种主要视角：
                <p>
                  &emsp;- <strong>正视图：</strong>俯视太阳系平面<br>
                  &emsp;- <strong>侧视图：</strong>平行于黄道观察<br>
                  &emsp;- <strong>3D视图：</strong>沉浸式立体模拟
                </p>
                </p>
                <p>用户可以在<strong>控制面板</strong>中的视图页自由选择，也可通过<strong>小工具条</strong>中的控件快速切换.</p>
                <p>在3D视图下，可以按住左键拖动以旋转视角，滚动滚轮以缩放画面，实时调整相机位置.</p>
              </div>
            </li>
            <li id="helpPage3" class="helpPage">
              <h2>日月食画中画</h2>
              <div class="helpContent">
                <p>Solar System Sim 提供了画中画功能，用于更清晰的展示<strong>月相变化、日食和月食</strong>的发生过程.</p>
                <p>主显示区的模拟已经表现了真实的天体自转、公转比例，考虑了白道随沙罗周期的进动，渲染了正确的光影投射关系.</p>
                <p>通过控制面板中的开关可以打开画中画小窗口，其中将同步主显示区月相盈亏、和日月食状态（涵盖全食、偏食、环食），更进一步的展示光线变化和阴影遮挡效果。画中画还提供月球距离调节功能，可以选择近地点、远地点或平均距离，动态展示不同距离下的日全食和日环食效果，从而帮助用户理解这些复杂现象的形成机制.</p>
                <p>考虑到日月食天象频次小、时间短，为了方便观察，在控制面板参数页也提供了快速跳转到指定天象的功能。</p>
              </div>
            </li>
            <li id="helpPage4" class="helpPage">
              <h2>运动调节</h2>
              <div class="helpContent">
                <p>Solar System Sim 支持灵活的<strong>速度调节</strong>与<strong>快速跳转</strong>功能.</p>
                <p>
                  仪表盘会显示当前速度比例和天象进程等基本状态信息
                </p>
                <p>
                  通过控制面板上的控件，可以方便的调节模拟过程的速度、进行暂停和倒退（小工具条也提供了暂停和速度调整的快捷按钮）、快捷跳转到指定日期或指定天象。
                </p>
                <p>
                  无论是想静止分析某一时刻的天体位置，还是连续观察一年间月相变化，都能自由切换。所有操作之间相互兼容，效果实时反馈在显示区和仪表盘，确保数据准确、操作流畅
                </p>
              </div>
            </li>
            <li id="helpPage5" class="helpPage">
              <h2>其他功能</h2>
              <div class="helpContent">
                <ul>
                  <li><strong>截图：</strong>在小工具条中，一键保存并下载当前模拟画面</li>
                  <li><strong>贴图切换：</strong>允许随时为太阳、地球选择不同的外观贴图，或修改宇宙背景</li>
                  <li><strong>辅助显示：</strong>可以打开自转轴、轨道面法向量、黄白交点等视觉辅助，更精细的观察交角及其变化</li>
                </ul>
              </div>
            </li>
          </ul>
        </div>
        <button id="nextPageBtn">&#62;</button>
      </div>
      <nav id="pageSwitcher">
        <ul>
          <li><button class="dot active" onclick="jumpToHelpPage(0)"></button></li>
          <li><button class="dot" onclick="jumpToHelpPage(1)"></button></li>
          <li><button class="dot" onclick="jumpToHelpPage(2)"></button></li>
          <li><button class="dot" onclick="jumpToHelpPage(3)"></button></li>
          <li><button class="dot" onclick="jumpToHelpPage(4)"></button></li>
          <li><button class="dot" onclick="jumpToHelpPage(5)"></button></li>
        </ul>
      </nav>
    </div>

  <!--------------------------------------------->
  <!------------ 下面是JavaScript代码 ------------>
  <!--------------------------------------------->
  <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
  <script>
    /* * * * * * * * * *
     * 重要全局变量定义
     * * * * * * * * * */
    // 公共变量：控件
    const controlBtn = document.getElementById('controlBtn');
    const controlPanel = document.getElementById('controlPanel');
    const tabs = document.querySelectorAll('#tabs .tab');
    const panels = document.querySelectorAll('#panels .panel');
    const earthTextureRadios = document.querySelectorAll('#earthTexture input');
    const sunTextureRadios = document.querySelectorAll('#sunTexture input');
    const starlandRadios = document.querySelectorAll('#starland input');
    const axisSwitch = document.getElementById('axisSwitch');
    const moonNormalSwitch = document.getElementById('moonNormalSwitch');
    const moonNodesSwitch = document.getElementById('moonNodesSwitch');
    const speedInput = document.getElementById('speedInput');
    const speedLabel = document.getElementById('speedLabel');
    const reserveSwitch = document.getElementById('reserveSwitch');
    const stopSwitch = document.getElementById('stopSwitch');
    const dashboardSpeed = document.getElementById('db-speed');
    const dashboardSaros = document.getElementById('db-saros');
    const dashboardMoonPhase = document.getElementById('db-moonphase');
    const dashboardAlignment = document.getElementById('db-alignment');
    const toolPause = document.getElementById('toolPause');
    const toolSpeed = document.getElementById('toolSpeed');
    const pipContainer = document.getElementById('pipContainer');
    const pipMinimize = document.getElementById('pipMinimize');
    const pipClose = document.getElementById('pipClose');
    const PIPSwitch = document.getElementById('PIPSwitch');
    const prevPageBtn = document.getElementById('prevPageBtn');
    const nextPageBtn = document.getElementById('nextPageBtn');
    const helpModal = document.getElementById('modalMask');
    const helpPages = document.getElementById('helpPages');
    const pageSwitcherDots = document.querySelectorAll('#pageSwitcher .dot');
    let currentHelpPage = 0; // 当前帮助页面索引

    // 3D月相相关变量
    let pipScene = null;
    let pipCamera = null;
    let pipRenderer = null;
    let pip3DMoon = null;
    let pipSunLight = null;
    let pipAmbientLight = null;
    let lastPhaseAngle = 0;
    let lastIllumination = 0;
    let phaseTransitionSpeed = 0.02; // 降低过渡速度，使变化更平滑
    let lastSunLightPosition = { x: 5, y: 0, z: 0 }; // 记录上次光源位置
    let isControlPanelOpen = false;
    let mouseDragging = false;
    let isPipMinimized = false;
    let isPipVisible = false;
    let isEclipseMode = false;  // 是否为日食/月食模式
    let eclipse2DCanvas = null;  // 2D日食/月食Canvas
    let eclipse2DCtx = null;     // 2D绘图上下文
    let eclipseAnimationId = null; // 动画ID
    let cachedStars = null; // 缓存的星星位置
    let currentEclipseInfo = null; // 存储当前日食/月食的类型信息，确保整个过程保持一致
    // 统一的全食/偏食判断标准
    const ECLIPSE_THRESHOLDS = {
      TOTAL: 0.105,    // 约6度 - 全食阈值（调整为更合理的范围）
      PARTIAL: 0.26,   // 约15度 - 偏食阈值
      ALIGNMENT: 70    // 对齐程度阈值
    };

    /**
     * 统一的月食/日食类型判断函数
     * 确保所有地方使用完全相同的标准
     */
    function determineEclipseTypeUnified(minDistanceFromNode) {
      if (minDistanceFromNode < ECLIPSE_THRESHOLDS.TOTAL) {
        return 'total';
      } else if (minDistanceFromNode < ECLIPSE_THRESHOLDS.PARTIAL) {
        return 'partial';
      } else {
        return 'none';
      }
    }

    // 公共变量：天体和运动参数
    const frameRate = 60; //动画帧数
    const sunRotateAnglePerDay = 0.228729; //太阳每天自转的角度
    const earthRevolveAnglePerDay = 0.017202; //地球每天公转的角度（弧度）
    const earthRotateAnglePerDay = 6.283185; //地球每天自转的角度
    const moonRevolveAnglePerDay = 0.213707; // 补偿进动影响后的月球公转角速度，保持朔望月29.53天周期
    const moonRotateAnglePerDay = 0.229985; //月球每天自转的角度
    // 月球轨道进动：2π / (18.6年 × 365.25天) = 2π / 6793天 ≈ 0.000924
    const moonOrbitPrecessionPerDay = -0.000924; //月球轨道进动角速度（约18.6年一周期，逆行）
    const dateOrigin = new Date(2022, 11, 8); //日期原点（日地月共线，月球黄纬约为0）
    let dateCurrent = new Date(dateOrigin); //当前日期
    let days = 0;             //经历天数（当前日期与原点相差天数）
    const sarosCurrent = 6585.32; //沙罗周期：6585.32天
    let speedFactor = 1;      //速度因子
    let isPaused = false;     //暂停
    let isbackwards = false;  //倒退
    //视角相关参数
    let isViewLocked = false; //是否是3D视角
    let targetAzimuth = 0;     // 水平角
    let targetElevation = 0;   // 垂直角
    let targetRadius = 10;    // 距离
    let startMouseX = 0;
    let startMouseY = 0;
    let startAzimuth = 0;
    let startElevation = 0;
    let mouseOnPanel = false;
    // 公共变量：场景、相机、渲染器、纹理
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.z = 10;
    const renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.body.appendChild(renderer.domElement);
    let rendererLock = false;    //渲染器锁
    const textureLoader = new THREE.TextureLoader();
    const sunTextureTrue = textureLoader.load('https://cdn.jsdelivr.net/gh/isXSong/FigureBed/SolarSystem/sun.jpg');
    const sunTextureOrange = textureLoader.load('https://cdn.jsdelivr.net/gh/isXSong/FigureBed/SolarSystem/orange.jpg');
    const earthTextureSatellite = textureLoader.load('https://cdn.jsdelivr.net/gh/isXSong/FigureBed/SolarSystem/earth-sate.jpg');
    const earthTextureCommon = textureLoader.load("https://cdn.jsdelivr.net/gh/isXSong/FigureBed/SolarSystem/earth-common.png");
    const earthTextureBlue = textureLoader.load("https://cdn.jsdelivr.net/gh/isXSong/FigureBed/SolarSystem/transparent.png");
    const moonTexture = textureLoader.load("https://cdn.jsdelivr.net/gh/isXSong/FigureBed/SolarSystem/moon.png");


    /* * * * * * * * * *
     * 3D场景初始化
     * 层次结构说明：
     * scene
     * ├── sun (太阳：自转)
     * ├── earthOrbit (地球轨道：绕太阳公转)
     * │   └── earthGroup (地球整体组合，位于轨道上)
     * │       ├── earthRotationGroup (地球自转组：只包含地球球体)
     * │       │   └── earthSphere (地球球体：跟随地球自转)
     * │       ├── moonOrbitGroup (月球轨道组：相对黄道面倾斜5.15°，Z轴倾斜)
     * │       │   └── moonOrbit (月球轨道：绕地球公转)
     * │       │       └── moon (月球：潮汐锁定，一面朝地球)
     * │       └── earthAxisGroup (地轴组：倾斜23.5°，Z轴倾斜，不自转)
     * │           ├── earthAxis (地轴线)
     * │           ├── northArrow (北极箭头)
     * │           └── southArrow (南极箭头)
     * ├── earthOrbitRing (地球轨道环)
     * └── starfield (星空背景)
     * 
     * 倾斜方向说明：
     * - 地轴倾斜23.5°，Z轴正方向倾斜(夏至时北极朝向太阳)
     * - 月球轨道倾斜-5.15°，Z轴负方向，与地轴倾斜方向相对
     * - 这种相对倾斜使得月球轨道与黄道面有交点，是日月食发生的关键
     * * * * * * * * * */
    // 设置背景
    scene.background = new THREE.Color(0x0d0f13);

    // 创建太阳
    const sunGeometry = new THREE.SphereGeometry(2, 32, 32);
    const sunMaterial = new THREE.MeshLambertMaterial({
      map: sunTextureTrue,
      color: 0xfcf083,
      emissive: 0xfcf083,
      emissiveMap: sunTextureTrue,
      emissiveIntensity: 0.8
    });
    const sun = new THREE.Mesh(sunGeometry, sunMaterial);
    scene.add(sun);

    // 光源：太阳光和环境光
    const sunLight = new THREE.PointLight(0xffffff, 100, 1000);
    sunLight.position.set(0, 0, 0);
    sunLight.castShadow = true;
    sunLight.shadow.mapSize.width = 2048;
    sunLight.shadow.mapSize.height = 2048;
    scene.add(sunLight);
    const ambientLight = new THREE.AmbientLight(0x101010, 30);
    scene.add(ambientLight);

    // 创建地球本体（只包含球体，不包含地轴）
    const earthGeometry = new THREE.SphereGeometry(0.5, 32, 32);
    const earthMaterial = new THREE.MeshPhongMaterial({ 
      color: 0xcfe3fc,
      shininess: 30,
      map: earthTextureSatellite,
    });
    earthMaterial.needUpdate = true;
    const earthSphere = new THREE.Mesh(earthGeometry, earthMaterial);
    earthSphere.castShadow = true;
    earthSphere.receiveShadow = true;

    // 创建地球自转组（只包含地球球体）
    const earthRotationGroup = new THREE.Object3D();
    earthRotationGroup.add(earthSphere);

    // 创建月球
    const moonGeometry = new THREE.SphereGeometry(0.15, 16, 16);
    const moonMaterial = new THREE.MeshPhongMaterial({ 
      color: 0xcccccc,
      map: moonTexture,
      shininess: 10
    });
    const moon = new THREE.Mesh(moonGeometry, moonMaterial);
    moon.castShadow = true;
    moon.receiveShadow = true;

    // 月球轨道组（绕地球公转）
    const moonOrbit = new THREE.Object3D();
    moonOrbit.add(moon);
    moon.position.x = 1.2;

    // 月球轨道倾斜组（相对黄道面倾斜5.15°）
    const moonOrbitGroup = new THREE.Object3D();
    moonOrbitGroup.add(moonOrbit);
    // 月球轨道相对黄道面倾斜5.15度，倾斜方向与地轴相关
    // 使用Z轴负方向倾斜，与地轴倾斜方向相对
    moonOrbitGroup.rotation.z = THREE.MathUtils.degToRad(-5.15);
    
    // 注意：月球轨道的进动
    // 1. moonOrbit.rotation.y 控制月球绕地球的公转（约27.3天一周期）
    // 2. moonOrbitGroup.rotation.y 控制月球轨道面的进动（约18.6年一周期）
    // 3. 月球轨道平面相对于黄道面倾斜约5.15度，倾斜方向与地轴相对
    // 4. 月球轨道平面的方向会缓慢进动，交点线在黄道面上旋转

    // 创建月球轨道法向量（显示轨道面的法线方向）
    const moonOrbitNormalGeometry = new THREE.CylinderGeometry(0.01, 0.01, 1.5, 8);
    const moonOrbitNormalMaterial = new THREE.MeshBasicMaterial({ 
      color: 0xff0088,
      transparent: true,
      opacity: 1.0
    });
    const moonOrbitNormal = new THREE.Mesh(moonOrbitNormalGeometry, moonOrbitNormalMaterial);

    // 创建法向量箭头（正方向）
    const normalArrowGeometry = new THREE.ConeGeometry(0.03, 0.12, 8);
    const normalArrowMaterial = new THREE.MeshBasicMaterial({ 
      color: 0xff0088,
      transparent: true,
      opacity: 1.0
    });
    const normalArrowUp = new THREE.Mesh(normalArrowGeometry, normalArrowMaterial);
    normalArrowUp.position.set(0, 0.81, 0);

    // 创建法向量箭头（负方向）
    const normalArrowDown = new THREE.Mesh(normalArrowGeometry, normalArrowMaterial);
    normalArrowDown.position.set(0, -0.81, 0);
    normalArrowDown.rotation.x = Math.PI;

    // 月球轨道法向量组（位于轨道中心，垂直于轨道平面）
    const moonOrbitNormalGroup = new THREE.Object3D();
    moonOrbitNormalGroup.add(moonOrbitNormal);
    moonOrbitNormalGroup.add(normalArrowUp);
    moonOrbitNormalGroup.add(normalArrowDown);
    
    // 将法向量添加到月球轨道组中，这样它会跟随轨道倾斜和进动
    moonOrbitGroup.add(moonOrbitNormalGroup);

    // 创建黄白交点标记（月球轨道与黄道面的交点）
    // 升交点（从黄道面下方穿过到上方）
    const ascendingNodeGeometry = new THREE.SphereGeometry(0.08, 16, 16);
    const ascendingNodeMaterial = new THREE.MeshBasicMaterial({ 
      color: 0x00ff00,  // 绿色表示升交点
      transparent: true,
      opacity: 0.9
    });
    const ascendingNode = new THREE.Mesh(ascendingNodeGeometry, ascendingNodeMaterial);
    
    // 降交点（从黄道面上方穿过到下方）
    const descendingNodeGeometry = new THREE.SphereGeometry(0.08, 16, 16);
    const descendingNodeMaterial = new THREE.MeshBasicMaterial({ 
      color: 0xff0000,  // 红色表示降交点
      transparent: true,
      opacity: 0.9
    });
    const descendingNode = new THREE.Mesh(descendingNodeGeometry, descendingNodeMaterial);
    
    // 黄白交点位于月球轨道上，距离地球1.2个单位
    // 考虑到轨道倾斜的几何关系，交点应该在z轴方向
    // 升交点位于角度π/2的位置，降交点位于角度3π/2的位置
    const moonOrbitRadius = 1.2;
    ascendingNode.position.set(0, 0, moonOrbitRadius);
    descendingNode.position.set(0, 0, -moonOrbitRadius);
    
    // 将交点添加到月球轨道组中，这样它们会跟随轨道倾斜和进动
    moonOrbitGroup.add(ascendingNode);
    moonOrbitGroup.add(descendingNode);
    
    // 创建交点标签
    const nodeLabels = createNodeLabels();
    moonOrbitGroup.add(nodeLabels.ascending);
    moonOrbitGroup.add(nodeLabels.descending);

    // 创建地轴（独立的组，不跟随地球自转）
    const axisGeometry = new THREE.CylinderGeometry(0.005, 0.005, 1.5, 8);
    const axisMaterial = new THREE.MeshBasicMaterial({ 
      color: 0xff4444,
      transparent: true,
      opacity: 0.8
    });
    const earthAxis = new THREE.Mesh(axisGeometry, axisMaterial);

    // 创建地轴箭头（北极端）
    const arrowGeometry = new THREE.ConeGeometry(0.02, 0.08, 8);
    const arrowMaterial = new THREE.MeshBasicMaterial({ 
      color: 0xff4444,
      transparent: true,
      opacity: 0.8
    });
    const northArrow = new THREE.Mesh(arrowGeometry, arrowMaterial);
    northArrow.position.set(0, 0.79, 0);

    // 创建地轴箭头（南极端）
    const southArrow = new THREE.Mesh(arrowGeometry, arrowMaterial);
    southArrow.position.set(0, -0.79, 0);
    southArrow.rotation.x = Math.PI;

    // 地轴组（包含轴线和箭头，有倾斜角度但不自转）
    const earthAxisGroup = new THREE.Object3D();
    earthAxisGroup.add(earthAxis);
    earthAxisGroup.add(northArrow);
    earthAxisGroup.add(southArrow);
    // 地轴倾斜23.5度
    earthAxisGroup.rotation.z = THREE.MathUtils.degToRad(23.5);

    // 地球整体组（包含自转组 + 月球轨道组 + 地轴组）
    const earthGroup = new THREE.Object3D();
    earthGroup.add(earthRotationGroup);
    earthGroup.add(moonOrbitGroup);
    earthGroup.add(earthAxisGroup);

    // 地球轨道组（地球整体绕太阳公转）
    const earthOrbit = new THREE.Object3D();
    earthOrbit.add(earthGroup);
    earthGroup.position.x = 5;
    scene.add(earthOrbit);

    // 地球、月球轨道环显示
    const earthOrbitGeometry = new THREE.RingGeometry(4.8, 5.2, 64);
    const earthOrbitMaterial = new THREE.MeshBasicMaterial({ 
      color: 0x444444, 
      side: THREE.DoubleSide,
      transparent: true,
      opacity: 0.3
    });
    const earthOrbitRing = new THREE.Mesh(earthOrbitGeometry, earthOrbitMaterial);
    earthOrbitRing.rotation.x = -Math.PI / 2;
    scene.add(earthOrbitRing);
    const moonOrbitGeometry = new THREE.RingGeometry(1.1, 1.3, 32);
    const moonOrbitMaterial = new THREE.MeshBasicMaterial({ 
      color: 0x888888, 
      side: THREE.DoubleSide,
      transparent: true,
      opacity: 0.4
    });
    const moonOrbitRing = new THREE.Mesh(moonOrbitGeometry, moonOrbitMaterial);
    moonOrbitRing.rotation.x = -Math.PI / 2;
    // 月球轨道环相对于月球轨道组的倾斜需要考虑到组本身的倾斜
    moonOrbitGroup.add(moonOrbitRing);

    // 创建交点标签的函数
    function createNodeLabels() {
      // 创建升交点标签
      const canvas1 = document.createElement('canvas');
      canvas1.width = 128;
      canvas1.height = 64;
      const context1 = canvas1.getContext('2d');
      context1.font = '16px Arial';
      context1.fillStyle = '#00ff00';
      context1.textAlign = 'center';
      context1.fillText('升交点', 64, 32);
      
      const texture1 = new THREE.CanvasTexture(canvas1);
      const material1 = new THREE.SpriteMaterial({ map: texture1 });
      const ascending = new THREE.Sprite(material1);
      ascending.position.set(0, 0.2, 1.2);
      ascending.scale.set(0.5, 0.25, 1);
      
      // 创建降交点标签
      const canvas2 = document.createElement('canvas');
      canvas2.width = 128;
      canvas2.height = 64;
      const context2 = canvas2.getContext('2d');
      context2.font = '16px Arial';
      context2.fillStyle = '#ff0000';
      context2.textAlign = 'center';
      context2.fillText('降交点', 64, 32);
      
      const texture2 = new THREE.CanvasTexture(canvas2);
      const material2 = new THREE.SpriteMaterial({ map: texture2 });
      const descending = new THREE.Sprite(material2);
      descending.position.set(0, 0.2, -1.2);
      descending.scale.set(0.5, 0.25, 1);
      
      return { ascending, descending };
    }

    //星空
    const starfield = createStarfield(scene, 2000, 800);
    function createStarfield(scene, count = 10000, radius = 1000) {
      const positions = new Float32Array(count * 3);
      for (let i = 0; i < count; i++) {
          const i3 = i * 3;
          const phi = Math.random() * Math.PI * 2; 
          const theta = Math.random() * Math.PI;   
          positions[i3] = radius * Math.sin(theta) * Math.cos(phi); 
          positions[i3 + 1] = radius * Math.sin(theta) * Math.sin(phi);
          positions[i3 + 2] = radius * Math.cos(theta);
      }
      const geometry = new THREE.BufferGeometry();
      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      const material = new THREE.PointsMaterial({
          color: 0xffffff,
          size: 2, 
          sizeAttenuation: true,
          transparent: true,   
          opacity: 0.8           
      });
      const starfield = new THREE.Points(geometry, material);
      starfield.renderOrder = -100;
      starfield.frustumCulled = false; 
      scene.add(starfield);
      return starfield;
    }

    // 鼠标控制
    let mouseX = 0, mouseY = 0;
    let targetX = 0, targetY = 0;
    const windowHalfX = window.innerWidth / 2;
    const windowHalfY = window.innerHeight / 2;
    
    document.addEventListener('mousedown', (event) => {
        mouseDragging = true;
        startMouseX = event.clientX;
        startMouseY = event.clientY;
        startAzimuth = targetAzimuth;
        startElevation = targetElevation;
    })
    document.addEventListener('mouseup', (event) => {
      mouseDragging = false;
    });
    
    document.addEventListener('mousemove', (event) => {
        if (!mouseDragging || isViewLocked || mouseOnPanel) return;

        const dx = event.clientX - startMouseX;
        const dy = event.clientY - startMouseY;

        // 调整灵敏度
        targetAzimuth = startAzimuth - dx * 0.005;
        targetElevation = startElevation + dy * 0.005;

        // 限制 elevation（仰角）范围
        const maxElevation = Math.PI / 2 - 0.01;
        const minElevation = -Math.PI / 2 + 0.01;
        targetElevation = Math.max(minElevation, Math.min(maxElevation, targetElevation));
    });
    document.addEventListener('wheel', (event) => {
        if(isViewLocked || mouseOnPanel) return;
        const delta = Math.sign(event.deltaY);
        targetRadius += delta * 0.5; // 调整缩放灵敏度
        targetRadius = Math.max(3, Math.min(15, targetRadius)); // 限制缩放范围
      })

    /* * * * * * * * * *
     * 动画更新
     * * * * * * * * * */
    function animate() {
      requestAnimationFrame(animate);
      // 运动和时间更新
      if(!isPaused){     
        var dayDelta = 1 / 60 * speedFactor;
        if(isbackwards) dayDelta = -dayDelta;
        stepSimulation(dayDelta);
      }
        // 相机控制
        if (!isViewLocked) {
            const r = targetRadius; // 相机半径

            const x = r * Math.cos(targetElevation) * Math.sin(targetAzimuth);
            const y = r * Math.sin(targetElevation);
            const z = r * Math.cos(targetElevation) * Math.cos(targetAzimuth);

            camera.position.set(x, y, z);
            camera.up.set(0, 1, 0);
            camera.lookAt(scene.position);
        }

      if(!rendererLock)  renderer.render(scene, camera);
    }
    
    animate();

    /* * * * * * * * * *
     * 3D月相渲染功能
     * * * * * * * * * */
    
    /**
     * 初始化3D月相场景
     */
    function init3DMoonPhase() {
      const container = document.getElementById('moonPhase3D');
      if (!container) {
        console.warn('3D月相容器未找到');
        return false;
      }
      
      try {
        // 创建场景
        pipScene = new THREE.Scene();
        // 背景颜色将通过 renderer.setClearColor 动态设置
        
        // 创建相机
        const containerRect = container.getBoundingClientRect();
        pipCamera = new THREE.PerspectiveCamera(
          50,
          containerRect.width / containerRect.height,
          0.1,
          100
        );
        pipCamera.position.set(0, 0, 3); // 地球视角：从Z轴正方向看月球
        pipCamera.lookAt(0, 0, 0); // 朝向月球中心
        
        // 创建渲染器
        pipRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
        pipRenderer.setSize(containerRect.width, containerRect.height);
        pipRenderer.shadowMap.enabled = true;
        pipRenderer.shadowMap.type = THREE.PCFSoftShadowMap;
        pipRenderer.outputEncoding = THREE.sRGBEncoding;
        pipRenderer.toneMapping = THREE.ACESFilmicToneMapping;
        pipRenderer.toneMappingExposure = 1.2;
        
        container.appendChild(pipRenderer.domElement);
        
        // 创建3D月球
        create3DMoon();
        
        // 创建光照
        create3DLighting();
        
        // 背景颜色将根据月相动态设置，不在此处固定
        
        // 开始渲染循环
        start3DMoonAnimation();
        
        // 直接使用同步方式初始化月相显示
        const syzygyData = calculateSyzygyProgress();
        updatePipMoonPhase(syzygyData);
        
        console.log('3D月相场景初始化成功');
        return true;
      } catch (error) {
        console.error('3D月相场景初始化失败:', error);
        return false;
      }
    }
    
    /**
     * 创建3D月球
     */
    function create3DMoon() {
      // 月球几何体
      const moonGeometry = new THREE.SphereGeometry(1, 64, 64);
      
      // 月球材质
      const moonMaterial = new THREE.MeshPhongMaterial({
        color: 0xcccccc,
        shininess: 5,
        transparent: false
      });
      
      // 如果有月球纹理，使用纹理
      if (typeof moonTexture !== 'undefined') {
        moonMaterial.map = moonTexture;
      }
      
      // 创建月球mesh
      pip3DMoon = new THREE.Mesh(moonGeometry, moonMaterial);
      pip3DMoon.castShadow = true;
      pip3DMoon.receiveShadow = true;
      
      // 潮汐锁定：月球始终以同一面朝向地球（观察者）
      // 设置初始朝向，确保月球表面特征始终面向观察者
      pip3DMoon.rotation.y = 0;
      pip3DMoon.rotation.x = 0;
      pip3DMoon.rotation.z = 0;
      
      // 添加法线贴图效果（模拟月球表面凹凸）
      const bumpTexture = createMoonBumpTexture();
      moonMaterial.bumpMap = bumpTexture;
      moonMaterial.bumpScale = 0.1;
      
      pipScene.add(pip3DMoon);
    }
    
    /**
     * 创建月球凹凸纹理
     */
    function createMoonBumpTexture() {
      const canvas = document.createElement('canvas');
      canvas.width = 512;
      canvas.height = 512;
      const ctx = canvas.getContext('2d');
      
      // 创建噪声纹理模拟月球表面
      const imageData = ctx.createImageData(512, 512);
      const data = imageData.data;
      
      for (let i = 0; i < data.length; i += 4) {
        const x = (i / 4) % 512;
        const y = Math.floor((i / 4) / 512);
        
        // 使用多层噪声创建月球表面效果
        let noise = 0;
        noise += Math.sin(x * 0.02) * Math.cos(y * 0.02) * 0.3;
        noise += Math.sin(x * 0.05) * Math.cos(y * 0.05) * 0.2;
        noise += Math.random() * 0.1;
        
        // 添加一些"环形山"
        const craters = [
          {x: 128, y: 128, radius: 30},
          {x: 300, y: 200, radius: 20},
          {x: 400, y: 350, radius: 25},
          {x: 150, y: 400, radius: 15}
        ];
        
        craters.forEach(crater => {
          const dist = Math.sqrt((x - crater.x) ** 2 + (y - crater.y) ** 2);
          if (dist < crater.radius) {
            noise -= (1 - dist / crater.radius) * 0.3;
          }
        });
        
        const value = Math.max(0, Math.min(255, (noise + 0.5) * 255));
        data[i] = value;     // R
        data[i + 1] = value; // G
        data[i + 2] = value; // B
        data[i + 3] = 255;   // A
      }
      
      ctx.putImageData(imageData, 0, 0);
      
      const texture = new THREE.CanvasTexture(canvas);
      texture.wrapS = THREE.RepeatWrapping;
      texture.wrapT = THREE.RepeatWrapping;
      return texture;
    }
    
    /**
     * 创建3D光照系统
     */
    function create3DLighting() {
      // 主光源（太阳光）
      pipSunLight = new THREE.DirectionalLight(0xffffff, 2.5);
      pipSunLight.position.set(5, 0, 0);
      pipSunLight.castShadow = true;
      pipSunLight.shadow.mapSize.width = 1024;
      pipSunLight.shadow.mapSize.height = 1024;
      pipSunLight.shadow.camera.near = 0.1;
      pipSunLight.shadow.camera.far = 10;
      pipSunLight.shadow.camera.left = -2;
      pipSunLight.shadow.camera.right = 2;
      pipSunLight.shadow.camera.top = 2;
      pipSunLight.shadow.camera.bottom = -2;
      pipScene.add(pipSunLight);
      
      // 环境光（微弱，模拟宇宙中的散射光）
      pipAmbientLight = new THREE.AmbientLight(0x404060, 0.1);
      pipScene.add(pipAmbientLight);
      
      // 添加一些点光源模拟地球反射光
      const earthLight = new THREE.PointLight(0x6699ff, 0.2, 10);
      earthLight.position.set(-3, 1, 2);
      pipScene.add(earthLight);
    }
    
    /**
     * 根据月相计算最佳观测时间的天空颜色 - 自然淡雅的天空渐变
     */
    function calculateSkyColor(moonRelativeAngle) {
      // 将角度标准化到 [0, 2π] 范围
      let normalizedAngle = ((moonRelativeAngle % (2 * Math.PI)) + 2 * Math.PI) % (2 * Math.PI);
      
      // 更自然、更淡雅的天空颜色
      const colors = {
        newMoon: { r: 18, g: 32, b: 47 },        // 新月：深蓝夜空
        firstQuarter: { r: 60, g: 50, b: 80 },   // 上弦月：淡紫黎明
        fullMoon: { r: 135, g: 206, b: 235 },   // 满月：经典天蓝色（白天）
        lastQuarter: { r: 255, g: 165, b: 79 }  // 下弦月：自然橙色晚霞
      };
      
      // 添加中间过渡色，让夜晚时间更长
      let targetColor;
      
      if (normalizedAngle < Math.PI / 6) {
        // 新月区域：深夜蓝（扩大夜晚范围）
        targetColor = colors.newMoon;
      } else if (normalizedAngle < Math.PI / 3) {
        // 深夜到黎明前
        const t = (normalizedAngle - Math.PI / 6) / (Math.PI / 6);
        const smoothT = t * t * (3 - 2 * t); // smoothstep
        targetColor = {
          r: Math.round(colors.newMoon.r + (colors.firstQuarter.r - colors.newMoon.r) * smoothT),
          g: Math.round(colors.newMoon.g + (colors.firstQuarter.g - colors.newMoon.g) * smoothT),
          b: Math.round(colors.newMoon.b + (colors.firstQuarter.b - colors.newMoon.b) * smoothT)
        };
      } else if (normalizedAngle < Math.PI / 2) {
        // 黎明到朝霞
        const t = (normalizedAngle - Math.PI / 3) / (Math.PI / 6);
        const smoothT = 0.5 * (1 + Math.sin(Math.PI * (t - 0.5))); // 正弦缓动
        // 过渡到淡朝霞色
        const dawnColor = { r: 173, g: 216, b: 230 }; // 淡蓝朝霞
        targetColor = {
          r: Math.round(colors.firstQuarter.r + (dawnColor.r - colors.firstQuarter.r) * smoothT),
          g: Math.round(colors.firstQuarter.g + (dawnColor.g - colors.firstQuarter.g) * smoothT),
          b: Math.round(colors.firstQuarter.b + (dawnColor.b - colors.firstQuarter.b) * smoothT)
        };
      } else if (normalizedAngle < 2 * Math.PI / 3) {
        // 朝霞到白天
        const t = (normalizedAngle - Math.PI / 2) / (Math.PI / 6);
        const smoothT = t * t * (3 - 2 * t);
        const dawnColor = { r: 173, g: 216, b: 230 };
        targetColor = {
          r: Math.round(dawnColor.r + (colors.fullMoon.r - dawnColor.r) * smoothT),
          g: Math.round(dawnColor.g + (colors.fullMoon.g - dawnColor.g) * smoothT),
          b: Math.round(dawnColor.b + (colors.fullMoon.b - dawnColor.b) * smoothT)
        };
      } else if (normalizedAngle < 4 * Math.PI / 3) {
        // 满月区域：明亮天蓝色（白天时间）
        targetColor = colors.fullMoon;
      } else if (normalizedAngle < 3 * Math.PI / 2) {
        // 白天到黄昏
        const t = (normalizedAngle - 4 * Math.PI / 3) / (Math.PI / 6);
        const smoothT = 0.5 * (1 + Math.sin(Math.PI * (t - 0.5)));
        // 过渡到温暖的黄昏橙色
        const goldenColor = { r: 255, g: 193, b: 128 }; // 温暖橙色
        targetColor = {
          r: Math.round(colors.fullMoon.r + (goldenColor.r - colors.fullMoon.r) * smoothT),
          g: Math.round(colors.fullMoon.g + (goldenColor.g - colors.fullMoon.g) * smoothT),
          b: Math.round(colors.fullMoon.b + (goldenColor.b - colors.fullMoon.b) * smoothT)
        };
      } else if (normalizedAngle < 5 * Math.PI / 3) {
        // 黄昏到日落
        const t = (normalizedAngle - 3 * Math.PI / 2) / (Math.PI / 6);
        const smoothT = t * t * (3 - 2 * t);
        const goldenColor = { r: 255, g: 193, b: 128 };
        targetColor = {
          r: Math.round(goldenColor.r + (colors.lastQuarter.r - goldenColor.r) * smoothT),
          g: Math.round(goldenColor.g + (colors.lastQuarter.g - goldenColor.g) * smoothT),
          b: Math.round(goldenColor.b + (colors.lastQuarter.b - goldenColor.b) * smoothT)
        };
      } else {
        // 日落到深夜（更长的夜晚过渡）
        const t = (normalizedAngle - 5 * Math.PI / 3) / (Math.PI / 3);
        const smoothT = 0.5 * (1 + Math.sin(Math.PI * (t - 0.5)));
        targetColor = {
          r: Math.round(colors.lastQuarter.r + (colors.newMoon.r - colors.lastQuarter.r) * smoothT),
          g: Math.round(colors.lastQuarter.g + (colors.newMoon.g - colors.lastQuarter.g) * smoothT),
          b: Math.round(colors.lastQuarter.b + (colors.newMoon.b - colors.lastQuarter.b) * smoothT)
        };
      }
      
      // 转换为16进制颜色
      const hexColor = (targetColor.r << 16) | (targetColor.g << 8) | targetColor.b;
      
      return hexColor;
    }
    
    /**
     * 颜色插值函数
     */
    function lerpColor(color1, color2, t) {
      const r1 = (color1 >> 16) & 0xff;
      const g1 = (color1 >> 8) & 0xff;
      const b1 = color1 & 0xff;
      
      const r2 = (color2 >> 16) & 0xff;
      const g2 = (color2 >> 8) & 0xff;
      const b2 = color2 & 0xff;
      
      const r = Math.round(r1 + (r2 - r1) * t);
      const g = Math.round(g1 + (g2 - g1) * t);
      const b = Math.round(b1 + (b2 - b1) * t);
      
      return (r << 16) | (g << 8) | b;
    }

    /**
     * 同步更新3D月相光照（直接匹配对齐程度，无过渡动画）
     */
    function update3DMoonPhaseSync(moonRelativeAngle, illumination) {
      if (!pipSunLight || !pip3DMoon) return;
      
      // 根据月相计算最佳观测时间的天空颜色
      const skyColor = calculateSkyColor(moonRelativeAngle);
      
      // 直接使用月球相对地球的角度，移除π/2修正
      const sunAngleFor3D = moonRelativeAngle;
      
      const sunDistance = 8;
      const targetSunX = Math.sin(sunAngleFor3D) * sunDistance;
      const targetSunY = 0; // 保持在赤道平面
      const targetSunZ = Math.cos(sunAngleFor3D) * sunDistance;
      
      // 更新背景颜色
      if (pipRenderer) {
        pipRenderer.setClearColor(skyColor, 1.0);
      }
      
      // 直接设置光源位置，不使用过渡动画
      pipSunLight.position.set(targetSunX, targetSunY, targetSunZ);
      pipSunLight.lookAt(0, 0, 0);
      
      // 直接设置光照强度
      const targetIntensity = 1.5 + illumination * 1.5;
      pipSunLight.intensity = targetIntensity;
      
      // 直接设置环境光
      const targetAmbient = 0.05 + illumination * 0.15;
      pipAmbientLight.intensity = targetAmbient;
      
      // 月球潮汐锁定 - 完全静止，不自转
      pip3DMoon.rotation.set(0, 0, 0);
      
      pipCamera.lookAt(0, 0, 0);
    }

    /**
     * 3D月相动画循环
     */
    function start3DMoonAnimation() {
      function animate3DMoon() {
        if (!pipRenderer || !pipScene || !pipCamera) return;
        
        requestAnimationFrame(animate3DMoon);
        
        // 只在画中画可见时渲染
        if (isPipVisible) {
          pipRenderer.render(pipScene, pipCamera);
        }
      }
      
      animate3DMoon();
    }
    
    /**
     * 调整3D月相渲染器大小
     */
    function resize3DMoonPhase() {
      if (!pipRenderer || !pipCamera) return;
      
      const container = document.getElementById('moonPhase3D');
      if (!container) return;
      
      const containerRect = container.getBoundingClientRect();
      if (containerRect.width === 0 || containerRect.height === 0) return;
      
      pipCamera.aspect = containerRect.width / containerRect.height;
      pipCamera.updateProjectionMatrix();
      pipRenderer.setSize(containerRect.width, containerRect.height);
    }
    
    /**
     * 清理3D月相资源
     */
    function cleanup3DMoonPhase() {
      if (pipRenderer) {
        const container = document.getElementById('moonPhase3D');
        if (container && pipRenderer.domElement.parentNode === container) {
          container.removeChild(pipRenderer.domElement);
        }
        pipRenderer.dispose();
        pipRenderer = null;
      }
      
      if (pipScene) {
        pipScene.clear();
        pipScene = null;
      }
      
      pipCamera = null;
      pip3DMoon = null;
      pipSunLight = null;
      pipAmbientLight = null;
    }

    /* * * * * * * * * *
     * 2D日食/月食动画功能
     * * * * * * * * * */

    /**
     * 初始化2D日食/月食Canvas
     */
    function init2DEclipse() {
      const container = document.getElementById('moonPhase3D');
      if (!container) {
        console.warn('2D日食/月食容器未找到');
        return false;
      }

      try {
        // 创建Canvas元素
        eclipse2DCanvas = document.createElement('canvas');
        eclipse2DCanvas.style.position = 'absolute';
        eclipse2DCanvas.style.top = '0';
        eclipse2DCanvas.style.left = '0';
        eclipse2DCanvas.style.width = '100%';
        eclipse2DCanvas.style.height = '100%';
        eclipse2DCanvas.style.zIndex = '10';
        
        // 设置Canvas尺寸
        const containerRect = container.getBoundingClientRect();
        eclipse2DCanvas.width = containerRect.width;
        eclipse2DCanvas.height = containerRect.height;
        
        // 获取绘图上下文
        eclipse2DCtx = eclipse2DCanvas.getContext('2d');
        
        // 添加到容器
        container.appendChild(eclipse2DCanvas);
        
        console.log('2D日食/月食Canvas初始化成功');
        return true;
      } catch (error) {
        console.error('2D日食/月食Canvas初始化失败:', error);
        return false;
      }
    }

    /**
     * 清理2D日食/月食Canvas
     */
    function cleanup2DEclipse() {
      if (eclipseAnimationId) {
        cancelAnimationFrame(eclipseAnimationId);
        eclipseAnimationId = null;
      }
      
      if (eclipse2DCanvas) {
        const container = document.getElementById('moonPhase3D');
        if (container && eclipse2DCanvas.parentNode === container) {
          container.removeChild(eclipse2DCanvas);
        }
        eclipse2DCanvas = null;
        eclipse2DCtx = null;
      }
      
      // 清理缓存的星星
      cachedStars = null;
    }

    /**
     * 获取月球大小比例（基于距离设置）
     * @param {string} eclipseType - 日食类型 ('total' 或 'partial')
     * @param {number} sunRadius - 太阳半径
     * @returns {number} 月球半径
     */
    function getMoonRadius(eclipseType, sunRadius) {
      const moonDistanceSelect = document.getElementById('pipMoonDistanceSelect');
      const moonDistance = moonDistanceSelect ? moonDistanceSelect.value : 'average';
      
      // 基础月球大小（相对于太阳）
      let baseScale;
      if (eclipseType === 'total') {
        baseScale = 1.05; // 日全食时月球需要稍大于太阳
      } else {
        baseScale = 0.95; // 日偏食时月球大小适中
      }
      
      // 根据月球距离调整大小 - 模拟月球视角大小变化
      let distanceScale = 1.0;
      switch (moonDistance) {
        case 'perigee': // 近地点：月球看起来更大（约356,500km）
          distanceScale = 1.15; // 增大15%，容易形成日全食
          break;
        case 'apogee': // 远地点：月球看起来更小（约406,700km）
          distanceScale = 0.85; // 减小15%，容易形成日环食
          break;
        case 'average': // 平均距离（约384,400km）
        default:
          distanceScale = 1.0;
          break;
      }
      
      return sunRadius * baseScale * distanceScale;
    }

    /**
     * 绘制2D日食动画
     * @param {number} progress - 食分进度 (0-1)
     * @param {string} eclipseType - 日食类型 ('total' 或 'partial')
     */
    function draw2DSolarEclipse(progress, eclipseType) {
      if (!eclipse2DCtx) return;

      const canvas = eclipse2DCanvas;
      const ctx = eclipse2DCtx;
      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;
      const sunRadius = Math.min(canvas.width, canvas.height) * 0.3;

      // 兼容新旧进度格式
      const timeProgress = typeof progress === 'object' ? progress.timeProgress : progress;
      const intensity = typeof progress === 'object' ? progress.intensity : progress;
      const combinedProgress = typeof progress === 'object' ? progress.combined : progress;

      // 清除画布
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // 根据日食类型绘制不同的背景
      const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, Math.max(canvas.width, canvas.height));
      
              if (eclipseType === 'total') {
          // 日全食：更戏剧化的天空变化（基于遮挡强度）
          if (intensity > 0.6) {
            // 接近全食时天空急剧变暗
            const darknessLevel = Math.min(1, (intensity - 0.6) / 0.4);
            gradient.addColorStop(0, `rgba(255, 223, 0, ${1 - darknessLevel * 0.95})`);
            gradient.addColorStop(0.2, `rgba(255, 140, 0, ${1 - darknessLevel * 0.9})`);
            gradient.addColorStop(0.4, `rgba(80, 40, 120, ${0.1 + darknessLevel * 0.7})`);
            gradient.addColorStop(0.7, `rgba(15, 20, 35, ${0.3 + darknessLevel * 0.7})`);
            gradient.addColorStop(1, `rgba(0, 0, 0, ${0.5 + darknessLevel * 0.5})`);
          } else {
            // 日全食前期：逐渐变暗的天空
            const shadowLevel = intensity * 0.7;
            gradient.addColorStop(0, `rgba(255, 223, 0, ${0.8 - shadowLevel})`);
            gradient.addColorStop(0.3, `rgba(255, 165, 0, ${0.9 - shadowLevel})`);
            gradient.addColorStop(0.6, `rgba(135, 170, 235, ${0.8 - shadowLevel * 0.6})`);
            gradient.addColorStop(1, `rgba(70, 100, 180, ${1 - shadowLevel * 0.4})`);
          }
        } else {
          // 日偏食：天空变化很温和，保持明亮
          const shadowLevel = intensity * 0.2;
          gradient.addColorStop(0, `rgba(255, 223, 0, ${0.5 - shadowLevel})`);
          gradient.addColorStop(0.3, `rgba(255, 165, 0, ${0.8 - shadowLevel})`);
          gradient.addColorStop(0.6, `rgba(135, 206, 235, ${0.9 - shadowLevel * 0.2})`);
          gradient.addColorStop(1, `rgba(70, 130, 180, ${1 - shadowLevel * 0.1})`);
        }

      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // 绘制太阳 - 根据日食类型调整亮度（基于遮挡强度）
      const sunGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, sunRadius);
      
      if (eclipseType === 'total' && intensity > 0.7) {
        // 日全食时太阳光芒减弱
        const dimFactor = 1 - (intensity - 0.7) / 0.3 * 0.6;
        sunGradient.addColorStop(0, `rgba(255, 215, 0, ${dimFactor})`);
        sunGradient.addColorStop(0.7, `rgba(255, 165, 0, ${dimFactor})`);
        sunGradient.addColorStop(1, `rgba(255, 140, 0, ${dimFactor})`);
      } else {
        sunGradient.addColorStop(0, '#FFD700');
        sunGradient.addColorStop(0.7, '#FFA500');
        sunGradient.addColorStop(1, '#FF8C00');
      }

      ctx.fillStyle = sunGradient;
      ctx.beginPath();
      ctx.arc(centerX, centerY, sunRadius, 0, 2 * Math.PI);
      ctx.fill();

              // 绘制太阳光芒 - 根据日食类型调整（基于遮挡强度）
        const raysOpacity = eclipseType === 'total' ? 
          Math.max(0.05, 0.6 - intensity * 0.8) : 
          Math.max(0.4, 0.6 - intensity * 0.2);
        
        ctx.strokeStyle = `rgba(255, 215, 0, ${raysOpacity})`;
        ctx.lineWidth = eclipseType === 'total' ? 2 : 4;
        
        const rayCount = eclipseType === 'total' ? 20 : 16;
        for (let i = 0; i < rayCount; i++) {
          const angle = (i / rayCount) * 2 * Math.PI;
          const rayLength = eclipseType === 'total' ? 
            (25 - intensity * 10) : 
            (40 - intensity * 5);
          const x1 = centerX + Math.cos(angle) * (sunRadius + 20);
          const y1 = centerY + Math.sin(angle) * (sunRadius + 20);
          const x2 = centerX + Math.cos(angle) * (sunRadius + rayLength);
          const y2 = centerY + Math.sin(angle) * (sunRadius + rayLength);
          
          ctx.beginPath();
          ctx.moveTo(x1, y1);
          ctx.lineTo(x2, y2);
          ctx.stroke();
        }

              // 绘制月球阴影（位置基于时间进度，遮挡强度基于天文条件）
        if (timeProgress > 0) {
          let currentX, currentY, moonRadius;
          
          // 使用新的月球大小计算函数
          moonRadius = getMoonRadius(eclipseType, sunRadius);
          
          if (eclipseType === 'total') {
            // 日全食：月球直接穿过太阳中心
            const totalDistance = sunRadius * 2.5;
            const startX = centerX + totalDistance * 0.9;
            const startY = centerY; // 保持在太阳中心水平线上
            const endX = centerX - totalDistance * 0.9;
            const endY = centerY; // 保持在太阳中心水平线上
            
            currentX = startX + (endX - startX) * timeProgress;
            currentY = startY + (endY - startY) * timeProgress;
            
          } else {
            // 日偏食：月球只擦过太阳的上方边缘
            const partialDistance = sunRadius * 2.0;
            const startX = centerX + partialDistance * 0.8;
            const startY = centerY - sunRadius * 0.7; // 偏离中心，从上方经过
            const endX = centerX - partialDistance * 0.8;
            const endY = centerY - sunRadius * 0.7; // 保持在上方
            
            currentX = startX + (endX - startX) * timeProgress;
            currentY = startY + (endY - startY) * timeProgress;
          }
        
        // 绘制月球阴影本体 - 只遮挡太阳本体，不遮挡光芒和背景天空
        ctx.save();
        
        // 创建太阳本体的裁剪区域（只遮挡太阳圆盘）
        ctx.beginPath();
        ctx.arc(centerX, centerY, sunRadius, 0, 2 * Math.PI);
        ctx.clip();
        
        // 在裁剪区域内绘制月球阴影
        const shadowOpacity = Math.min(0.95, 0.5 + intensity * 0.45);
        ctx.fillStyle = `rgba(0, 0, 0, ${shadowOpacity})`;
        ctx.beginPath();
        ctx.arc(currentX, currentY, moonRadius, 0, 2 * Math.PI);
        ctx.fill();
        
        ctx.restore();
        
        // 日食时月球本身不可见，不绘制边缘光晕
        // 月球只在遮挡太阳时才显示阴影效果，在太阳外部不显示任何痕迹
        
                  // 日全食特有的日冕效果（基于遮挡强度）
          if (eclipseType === 'total' && intensity > 0.5 && intensity < 0.95) {
            const coronaIntensity = intensity * (1 - Math.abs(timeProgress - 0.5) / 0.5);
            
            // 绘制内日冕（白色光晕）
            ctx.strokeStyle = `rgba(255, 255, 255, ${coronaIntensity * 1.0})`;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(centerX, centerY, sunRadius + 5, 0, 2 * Math.PI);
            ctx.stroke();
            
            // 绘制中日冕
            ctx.strokeStyle = `rgba(255, 255, 255, ${coronaIntensity * 0.8})`;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(centerX, centerY, sunRadius + 12, 0, 2 * Math.PI);
            ctx.stroke();
            
            // 绘制外日冕射线（更长更亮，形状不规则）
            ctx.strokeStyle = `rgba(255, 255, 255, ${coronaIntensity * 0.9})`;
            ctx.lineWidth = 2;
            for (let i = 0; i < 40; i++) {
              const angle = (i / 40) * 2 * Math.PI;
              const rayLength = 40 + Math.sin(angle * 3) * 15 + Math.random() * 25;
              const x1 = centerX + Math.cos(angle) * (sunRadius + 2);
              const y1 = centerY + Math.sin(angle) * (sunRadius + 2);
              const x2 = centerX + Math.cos(angle) * (sunRadius + rayLength);
              const y2 = centerY + Math.sin(angle) * (sunRadius + rayLength);
              
              ctx.beginPath();
              ctx.moveTo(x1, y1);
              ctx.lineTo(x2, y2);
              ctx.stroke();
            }
            
            // 绘制流光效果（更多更亮）
            ctx.strokeStyle = `rgba(220, 220, 255, ${coronaIntensity * 0.7})`;
            ctx.lineWidth = 1;
            for (let i = 0; i < 20; i++) {
              const angle = (i / 20) * 2 * Math.PI;
              const waveLength = 50 + Math.sin(Date.now() * 0.01 + i) * 15;
              const x1 = centerX + Math.cos(angle) * (sunRadius + 15);
              const y1 = centerY + Math.sin(angle) * (sunRadius + 15);
              const x2 = centerX + Math.cos(angle) * (sunRadius + waveLength);
              const y2 = centerY + Math.sin(angle) * (sunRadius + waveLength);
              
              ctx.beginPath();
              ctx.moveTo(x1, y1);
              ctx.lineTo(x2, y2);
              ctx.stroke();
            }
            
            // 绘制星星效果（全食时可见星星）
            if (intensity > 0.7) {
              ctx.fillStyle = `rgba(255, 255, 255, ${coronaIntensity * 0.8})`;
              for (let i = 0; i < 8; i++) {
                const angle = Math.random() * 2 * Math.PI;
                const distance = sunRadius * 2 + Math.random() * sunRadius;
                const x = centerX + Math.cos(angle) * distance;
                const y = centerY + Math.sin(angle) * distance;
                
                ctx.beginPath();
                ctx.arc(x, y, 2, 0, 2 * Math.PI);
                ctx.fill();
              }
            }
          }
        
                  // 日偏食特有的明暗对比效果
          if (eclipseType === 'partial' && intensity > 0.2) {
            // 绘制被遮挡太阳的剩余光芒 - 更强烈的对比
            const remainingLight = 1 - intensity * 0.5;
            ctx.strokeStyle = `rgba(255, 200, 0, ${remainingLight})`;
            ctx.lineWidth = 5;
            
            // 只在未被遮挡的部分绘制光芒
            for (let i = 0; i < 16; i++) {
              const angle = (i / 16) * 2 * Math.PI;
              const dx = Math.cos(angle);
              const dy = Math.sin(angle);
              
              // 检查这个方向是否被月球遮挡
              const testX = centerX + dx * sunRadius;
              const testY = centerY + dy * sunRadius;
              const distToMoon = Math.sqrt((testX - currentX) ** 2 + (testY - currentY) ** 2);
              
              if (distToMoon > moonRadius) {
                const x1 = centerX + dx * (sunRadius + 20);
                const y1 = centerY + dy * (sunRadius + 20);
                const x2 = centerX + dx * (sunRadius + 45);
                const y2 = centerY + dy * (sunRadius + 45);
                
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();
              }
            }
            
            // 绘制太阳剩余部分的增强光芒
            ctx.strokeStyle = `rgba(255, 215, 0, ${remainingLight * 0.8})`;
            ctx.lineWidth = 3;
            for (let i = 0; i < 8; i++) {
              const angle = (i / 8) * 2 * Math.PI;
              const dx = Math.cos(angle);
              const dy = Math.sin(angle);
              
              // 检查这个方向是否被月球遮挡
              const testX = centerX + dx * sunRadius;
              const testY = centerY + dy * sunRadius;
              const distToMoon = Math.sqrt((testX - currentX) ** 2 + (testY - currentY) ** 2);
              
              if (distToMoon > moonRadius) {
                const x1 = centerX + dx * (sunRadius + 10);
                const y1 = centerY + dy * (sunRadius + 10);
                const x2 = centerX + dx * (sunRadius + 30);
                const y2 = centerY + dy * (sunRadius + 30);
                
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();
              }
            }
            
            // 绘制新月形高光，突出显示太阳剩余部分
            if (progress > 0.4) {
              ctx.fillStyle = `rgba(255, 255, 0, ${remainingLight * 0.3})`;
              ctx.beginPath();
              ctx.arc(centerX, centerY, sunRadius, 0, 2 * Math.PI);
              ctx.fill();
              
              // 再次绘制月球阴影，形成新月形效果 - 只遮挡太阳本体
              ctx.save();
              
              // 创建太阳本体的裁剪区域（只遮挡太阳圆盘）
              ctx.beginPath();
              ctx.arc(centerX, centerY, sunRadius, 0, 2 * Math.PI);
              ctx.clip();
              
              // 在裁剪区域内绘制月球阴影
              ctx.fillStyle = 'rgba(0, 0, 0, 0.95)';
              ctx.beginPath();
              ctx.arc(currentX, currentY, moonRadius, 0, 2 * Math.PI);
              ctx.fill();
              
              ctx.restore();
            }
          }
      }

      // 绘制进度文字 - 根据日食类型调整颜色
      const textColor = eclipseType === 'total' && intensity > 0.7 ? 
        'rgba(255, 255, 255, 0.9)' : 
        'rgba(255, 255, 255, 0.9)';
      
      ctx.fillStyle = textColor;
      ctx.font = 'bold 16px Arial';
      ctx.textAlign = 'center';
      
      // 添加黑色描边以提高可读性
      ctx.strokeStyle = 'rgba(0, 0, 0, 0.7)';
      ctx.lineWidth = 2;
      
      const progressText = `${eclipseType === 'total' ? '日全食' : '日偏食'} ${(combinedProgress * 100).toFixed(1)}%`;
      ctx.strokeText(progressText, centerX, canvas.height - 20);
      ctx.fillText(progressText, centerX, canvas.height - 20);
      
              // 日全食时在全食阶段显示特殊标记
        if (eclipseType === 'total' && intensity > 0.75 && intensity < 0.9) {
          ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
          ctx.font = 'bold 14px Arial';
          ctx.strokeText('全食阶段 - 可见日冕', centerX, canvas.height - 45);
          ctx.fillText('全食阶段 - 可见日冕', centerX, canvas.height - 45);
        }
        
        // 显示轨迹类型提示
        if (timeProgress > 0.1 && timeProgress < 0.9) {
          ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
          ctx.font = '12px Arial';
          const trackText = eclipseType === 'total' ? '月球轨迹：穿过太阳中心' : '月球轨迹：擦过太阳上方';
          ctx.strokeText(trackText, centerX, 30);
          ctx.fillText(trackText, centerX, 30);
        }
    }

    /**
     * 绘制2D月食动画
     * @param {number} progress - 食分进度 (0-1)
     * @param {string} eclipseType - 月食类型 ('total' 或 'partial')
     */
    function draw2DLunarEclipse(progress, eclipseType) {
      if (!eclipse2DCtx) return;

      const canvas = eclipse2DCanvas;
      const ctx = eclipse2DCtx;
      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;
      const moonRadius = Math.min(canvas.width, canvas.height) * 0.3;

      // 兼容新旧进度格式
      const timeProgress = typeof progress === 'object' ? progress.timeProgress : progress;
      const intensity = typeof progress === 'object' ? progress.intensity : progress;
      const combinedProgress = typeof progress === 'object' ? progress.combined : progress;

      // 清除画布
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // 绘制夜空背景
      const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, Math.max(canvas.width, canvas.height));
      gradient.addColorStop(0, 'rgba(30, 30, 60, 0.3)');
      gradient.addColorStop(0.5, 'rgba(20, 20, 40, 0.7)');
      gradient.addColorStop(1, 'rgba(10, 10, 20, 1)');

      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // 绘制星星（使用缓存位置以保持一致性）
      ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
      
      // 如果没有缓存的星星或画布尺寸改变，重新生成
      if (!cachedStars || cachedStars.canvasWidth !== canvas.width || cachedStars.canvasHeight !== canvas.height) {
        cachedStars = {
          canvasWidth: canvas.width,
          canvasHeight: canvas.height,
          stars: []
        };
        
        // 生成50个随机星星位置
        for (let i = 0; i < 50; i++) {
          const x = Math.random() * canvas.width;
          const y = Math.random() * canvas.height;
          const radius = Math.random() * 2 + 1;
          
          // 避免在月球附近绘制星星
          const distanceFromMoon = Math.sqrt((x - centerX) ** 2 + (y - centerY) ** 2);
          if (distanceFromMoon > moonRadius + 50) {
            cachedStars.stars.push({ x, y, radius });
          }
        }
      }
      
      // 绘制缓存的星星
      cachedStars.stars.forEach(star => {
        ctx.beginPath();
        ctx.arc(star.x, star.y, star.radius, 0, 2 * Math.PI);
        ctx.fill();
      });

      // 绘制月球本体
      const moonGradient = ctx.createRadialGradient(
        centerX - moonRadius * 0.3, 
        centerY - moonRadius * 0.3, 
        0, 
        centerX, 
        centerY, 
        moonRadius
      );
      moonGradient.addColorStop(0, '#F5F5DC');
      moonGradient.addColorStop(0.7, '#E6E6FA');
      moonGradient.addColorStop(1, '#D3D3D3');

      ctx.fillStyle = moonGradient;
      ctx.beginPath();
      ctx.arc(centerX, centerY, moonRadius, 0, 2 * Math.PI);
      ctx.fill();

      // 绘制月球表面纹理
      ctx.fillStyle = 'rgba(180, 180, 180, 0.3)';
      for (let i = 0; i < 20; i++) {
        const angle = Math.random() * 2 * Math.PI;
        const distance = Math.random() * moonRadius * 0.8;
        const x = centerX + Math.cos(angle) * distance;
        const y = centerY + Math.sin(angle) * distance;
        const radius = Math.random() * 8 + 3;
        
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, 2 * Math.PI);
        ctx.fill();
      }

      // 绘制地球阴影（位置基于时间进度，强度基于天文条件）
      if (timeProgress > 0) {
        let shadowCurrentX, shadowCurrentY, umbraRadius, penumbraRadius;
        
        if (eclipseType === 'total') {
          // 月全食：阴影穿过月球中心，可以完全遮挡月球
          const shadowStartX = centerX - moonRadius * 1.3;
          const shadowEndX = centerX + moonRadius * 1.3;
          shadowCurrentX = shadowStartX + (shadowEndX - shadowStartX) * timeProgress;
          shadowCurrentY = centerY; // 保持在月球中心
          umbraRadius = moonRadius * 0.9; // 稍大一点，确保完全遮挡
          penumbraRadius = moonRadius * 1.2;
          
        } else {
          // 月偏食：阴影从月球上方经过，只覆盖部分月球
          const shadowStartX = centerX - moonRadius * 1.2;
          const shadowEndX = centerX + moonRadius * 1.2;
          shadowCurrentX = shadowStartX + (shadowEndX - shadowStartX) * timeProgress;
          
          // 阴影路径偏离月球中心，从上方经过
          const offsetY = moonRadius * 0.4; // 向上偏移，让阴影只覆盖月球下半部分
          shadowCurrentY = centerY - offsetY;
          
          umbraRadius = moonRadius * 0.7; // 稍小一点，突出偏食效果
          penumbraRadius = moonRadius * 1.0;
        }
        
        // 绘制本影（深色阴影）- 只遮挡月球本体，不遮挡光晕和背景星空
        ctx.save();
        
        // 创建月球本体的裁剪区域（只遮挡月球圆盘）
        ctx.beginPath();
        ctx.arc(centerX, centerY, moonRadius, 0, 2 * Math.PI);
        ctx.clip();
        
        const umbraGradient = ctx.createRadialGradient(
          shadowCurrentX, shadowCurrentY, 0,
          shadowCurrentX, shadowCurrentY, umbraRadius
        );
        
        if (eclipseType === 'total' && intensity > 0.3 && intensity < 0.7) {
          // 月全食时的红色效果（血月）
          const redIntensity = intensity * 0.9;
          umbraGradient.addColorStop(0, `rgba(139, 0, 0, ${redIntensity})`);
          umbraGradient.addColorStop(0.7, `rgba(100, 0, 0, ${redIntensity * 0.8})`);
          umbraGradient.addColorStop(1, `rgba(60, 0, 0, ${redIntensity * 0.6})`);
        } else {
          // 正常阴影效果
          const shadowIntensity = eclipseType === 'total' ? intensity * 0.95 : intensity * 0.8;
          umbraGradient.addColorStop(0, `rgba(0, 0, 0, ${shadowIntensity})`);
          umbraGradient.addColorStop(0.7, `rgba(0, 0, 0, ${shadowIntensity * 0.7})`);
          umbraGradient.addColorStop(1, `rgba(0, 0, 0, ${shadowIntensity * 0.3})`);
        }
        
        ctx.fillStyle = umbraGradient;
        ctx.beginPath();
        ctx.arc(shadowCurrentX, shadowCurrentY, umbraRadius, 0, 2 * Math.PI);
        ctx.fill();
        
        // 绘制半影（浅色阴影）- 也只在月球区域内
        const penumbraGradient = ctx.createRadialGradient(
          shadowCurrentX, shadowCurrentY, umbraRadius,
          shadowCurrentX, shadowCurrentY, penumbraRadius
        );
        
        const penumbraIntensity = eclipseType === 'total' ? intensity * 0.4 : intensity * 0.25;
        penumbraGradient.addColorStop(0, `rgba(0, 0, 0, ${penumbraIntensity})`);
        penumbraGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
        
        ctx.fillStyle = penumbraGradient;
        ctx.beginPath();
        ctx.arc(shadowCurrentX, shadowCurrentY, penumbraRadius, 0, 2 * Math.PI);
        ctx.fill();
        
        ctx.restore();
        
                  // 月偏食特效：强调月球剩余的明亮部分（在月球本体外绘制光环）
          if (eclipseType === 'partial' && intensity > 0.3) {
            ctx.save();
            
            // 创建月球本体外的裁剪（反向裁剪，排除月球本体）
            ctx.beginPath();
            ctx.rect(0, 0, canvas.width, canvas.height);
            ctx.arc(centerX, centerY, moonRadius, 0, 2 * Math.PI, true);
            ctx.clip();
          
          // 绘制月球未被遮挡部分的增强光芒
          const brightIntensity = (1 - intensity) * 0.4;
          ctx.strokeStyle = `rgba(255, 255, 255, ${brightIntensity})`;
          ctx.lineWidth = 3;
          
          // 只在月球上半部分绘制光环（未被阴影遮挡的部分）
          ctx.beginPath();
          ctx.arc(centerX, centerY - moonRadius * 0.2, moonRadius + 8, 0, Math.PI, true);
          ctx.stroke();
          
          // 额外的亮光效果
          ctx.strokeStyle = `rgba(240, 240, 255, ${brightIntensity * 0.6})`;
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.arc(centerX, centerY - moonRadius * 0.2, moonRadius + 15, 0, Math.PI, true);
          ctx.stroke();
          
          ctx.restore();
        }
        
                  // 月全食特效：增强血月效果（在月球本体外绘制光环）
          if (eclipseType === 'total' && intensity > 0.5) {
            ctx.save();
            
            // 创建月球本体外的裁剪（反向裁剪，排除月球本体）
            ctx.beginPath();
            ctx.rect(0, 0, canvas.width, canvas.height);
            ctx.arc(centerX, centerY, moonRadius, 0, 2 * Math.PI, true);
            ctx.clip();
          
          const bloodMoonIntensity = intensity * 0.3;
          
          // 绘制红色光晕
          ctx.strokeStyle = `rgba(139, 0, 0, ${bloodMoonIntensity})`;
          ctx.lineWidth = 4;
          ctx.beginPath();
          ctx.arc(centerX, centerY, moonRadius + 12, 0, 2 * Math.PI);
          ctx.stroke();
          
          // 外层红色光晕
          ctx.strokeStyle = `rgba(100, 0, 0, ${bloodMoonIntensity * 0.6})`;
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.arc(centerX, centerY, moonRadius + 20, 0, 2 * Math.PI);
          ctx.stroke();
          
          ctx.restore();
        }
      }

              // 绘制月球光晕（基于遮挡强度）- 只在月球本体外显示
        if (intensity < 0.8) {
          ctx.save();
          
          // 创建月球本体外的裁剪（反向裁剪，排除月球本体）
          ctx.beginPath();
          ctx.rect(0, 0, canvas.width, canvas.height);
          ctx.arc(centerX, centerY, moonRadius, 0, 2 * Math.PI, true);
          ctx.clip();
        
        const haloIntensity = 1 - intensity;
        ctx.strokeStyle = `rgba(255, 255, 255, ${haloIntensity * 0.3})`;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(centerX, centerY, moonRadius + 10, 0, 2 * Math.PI);
        ctx.stroke();
        
        ctx.restore();
      }

      // 绘制进度文字
      ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
      ctx.font = 'bold 16px Arial';
      ctx.textAlign = 'center';
      
      // 添加黑色描边以提高可读性
      ctx.strokeStyle = 'rgba(0, 0, 0, 0.7)';
      ctx.lineWidth = 2;
      
      const progressText = `${eclipseType === 'total' ? '月全食' : '月偏食'} ${(combinedProgress * 100).toFixed(1)}%`;
      ctx.strokeText(progressText, centerX, canvas.height - 20);
      ctx.fillText(progressText, centerX, canvas.height - 20);
      
      // 月全食时在血月阶段显示特殊标记
      if (eclipseType === 'total' && intensity > 0.5 && intensity < 0.8) {
        ctx.fillStyle = 'rgba(255, 100, 100, 0.9)';
        ctx.font = 'bold 14px Arial';
        ctx.strokeText('血月阶段 - 地球大气散射红光', centerX, canvas.height - 45);
        ctx.fillText('血月阶段 - 地球大气散射红光', centerX, canvas.height - 45);
      }
      
      // 显示轨迹类型提示
      if (timeProgress > 0.1 && timeProgress < 0.9) {
        ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
        ctx.font = '12px Arial';
        const trackText = eclipseType === 'total' ? 
          '地球阴影轨迹：穿过月球中心' : 
          '地球阴影轨迹：从月球上方经过';
        ctx.strokeText(trackText, centerX, 30);
        ctx.fillText(trackText, centerX, 30);
      }
    }

    /**
     * 确定日食/月食类型（基于食甚时刻的天文条件）
     * 这个函数会寻找完整日食/月食过程的峰值时刻，并确定整个过程的类型
     */
    function determineEclipseType(currentDay) {
      // 搜索当前时间前后5天内的所有可能的日食/月食时刻
      let bestAlignment = 0;
      let bestDay = currentDay;
      let bestEclipseType = 'partial';
      let bestEclipseKind = '';
      let bestNodeDistance = Infinity;
      
      // 扩大搜索范围，精度提高
      for (let dayOffset = -5; dayOffset <= 5; dayOffset += 0.05) {
        const testDay = currentDay + dayOffset;
        const syzygyData = calculateSyzygyProgressForDay(testDay);
        const nodeData = calculateMoonNodePosition(testDay);
        
        // 检查是否接近黄白交点且对齐程度足够高
        if (syzygyData.progress > ECLIPSE_THRESHOLDS.ALIGNMENT && nodeData.isNearNode) {
          // 判断是日食还是月食
          if (syzygyData.moonPhase < 20 || syzygyData.moonPhase > 340) {
            // 新月 - 日食
            if (syzygyData.progress > bestAlignment) {
              bestAlignment = syzygyData.progress;
              bestDay = testDay;
              bestEclipseKind = 'solar';
              bestNodeDistance = nodeData.minDistanceFromNode;
            }
          } else if (syzygyData.moonPhase > 160 && syzygyData.moonPhase < 200) {
            // 满月 - 月食
            if (syzygyData.progress > bestAlignment) {
              bestAlignment = syzygyData.progress;
              bestDay = testDay;
              bestEclipseKind = 'lunar';
              bestNodeDistance = nodeData.minDistanceFromNode;
            }
          }
        }
      }
      
      if (bestAlignment > 70) {
        // 根据食甚时刻的交点距离确定类型（只在这里确定一次）
        // 这个判断基于食甚时刻的天文条件，整个过程保持不变
        bestEclipseType = determineEclipseTypeUnified(bestNodeDistance);
        
        console.log(`确定${bestEclipseKind === 'solar' ? '日食' : '月食'}类型: ${bestEclipseType === 'total' ? '全食' : '偏食'}, 食甚时刻: ${bestDay.toFixed(2)}天, 最佳对齐: ${bestAlignment.toFixed(1)}%, 交点距离: ${(bestNodeDistance * 180 / Math.PI).toFixed(1)}°`);
        console.log(`使用统一标准 - 全食阈值: ${(ECLIPSE_THRESHOLDS.TOTAL * 180 / Math.PI).toFixed(1)}°, 偏食阈值: ${(ECLIPSE_THRESHOLDS.PARTIAL * 180 / Math.PI).toFixed(1)}°, 对齐阈值: ${ECLIPSE_THRESHOLDS.ALIGNMENT}%`);
        console.log(`类型判断依据: 交点距离 ${(bestNodeDistance * 180 / Math.PI).toFixed(1)}° ${bestNodeDistance < ECLIPSE_THRESHOLDS.TOTAL ? '<' : '>='} 全食阈值 ${(ECLIPSE_THRESHOLDS.TOTAL * 180 / Math.PI).toFixed(1)}° → ${bestEclipseType === 'total' ? '全食' : '偏食'}`);
        
        return {
          isEclipse: true,
          kind: bestEclipseKind,
          type: bestEclipseType,
          bestDay: bestDay,
          bestAlignment: bestAlignment,
          nodeDistance: bestNodeDistance
        };
      }
      
      return {
        isEclipse: false,
        kind: '',
        type: '',
        bestDay: currentDay,
        bestAlignment: 0,
        nodeDistance: Infinity
      };
    }
    
    /**
     * 计算日食/月食的进度
     * @param {Object} syzygyData - 对齐数据
     * @returns {Object} - 包含进度和类型的对象
     * 修改版：使用预先确定的日食类型，确保整个过程保持一致
     */
    function calculateEclipseProgress(syzygyData) {
      const nodeData = calculateMoonNodePosition(days);
      
      // 检查是否接近黄白交点且对齐程度足够高
      const isNearNode = nodeData.isNearNode;
      const alignmentProgress = syzygyData.progress;
      
      // 只有当对齐程度>阈值且接近交点时才认为是日食/月食
      if (alignmentProgress > ECLIPSE_THRESHOLDS.ALIGNMENT && isNearNode) {
        let eclipseProgress = 0;
        let isEclipse = false;
        let eclipseKind = '';
        let eclipseType = 'partial';
        
        // 判断是日食还是月食
        if (syzygyData.moonPhase < 20 || syzygyData.moonPhase > 340) {
          // 新月 - 日食
          isEclipse = true;
          eclipseKind = 'solar';
          
          // 检查是否需要重新确定日食类型
          // 如果是用户手动跳转的，绝不重新计算类型
          const isUserJumped = currentEclipseInfo && currentEclipseInfo.userJumped;
          const needsNewType = !currentEclipseInfo || 
                               (currentEclipseInfo.kind !== 'solar' && !isUserJumped);
          
          if (needsNewType && !isUserJumped) {
            console.log('重新确定日食类型，原因：', {
              noInfo: !currentEclipseInfo,
              wrongKind: currentEclipseInfo && currentEclipseInfo.kind !== 'solar',
              currentDay: days,
              bestDay: currentEclipseInfo ? currentEclipseInfo.bestDay : 'none'
            });
            currentEclipseInfo = determineEclipseType(days);
            console.log('确定日食类型：', currentEclipseInfo);
          } else {
            console.log('使用已存在的日食类型信息：', currentEclipseInfo.type, isUserJumped ? '(用户手动跳转，禁止重新计算)' : '');
          }
          
          // 使用预先确定的日食类型（整个过程保持不变）
          eclipseType = currentEclipseInfo.type;
          
          // 计算线性时间进度和遮挡强度
          const eclipseDuration = 3.0; // 日食持续时间约3天
          const eclipseStart = currentEclipseInfo.bestDay - eclipseDuration / 2;
          const eclipseEnd = currentEclipseInfo.bestDay + eclipseDuration / 2;
          
          if (days >= eclipseStart && days <= eclipseEnd) {
            // 线性时间进度（控制阴影位置）
            const timeProgress = (days - eclipseStart) / eclipseDuration;
            
            // 遮挡强度（基于对齐程度和交点距离）
            const alignmentFactor = Math.max(0, (alignmentProgress - ECLIPSE_THRESHOLDS.ALIGNMENT) / 30); // 0-1
            const nodeFactor = Math.max(0, 1 - nodeData.minDistanceFromNode / ECLIPSE_THRESHOLDS.PARTIAL); // 0-1
            const eclipseIntensity = alignmentFactor * nodeFactor;
            
            // 组合进度：时间进度控制位置，强度控制遮挡效果
            eclipseProgress = {
              timeProgress: timeProgress,
              intensity: eclipseIntensity,
              combined: timeProgress * Math.max(0.3, eclipseIntensity) // 确保最少30%的可见度
            };
          } else {
            eclipseProgress = {
              timeProgress: 0,
              intensity: 0,
              combined: 0
            };
          }
          
        } else if (syzygyData.moonPhase > 160 && syzygyData.moonPhase < 200) {
          // 满月 - 月食
          isEclipse = true;
          eclipseKind = 'lunar';
          
          // 检查是否需要重新确定月食类型
          // 如果是用户手动跳转的，绝不重新计算类型
          const isUserJumped = currentEclipseInfo && currentEclipseInfo.userJumped;
          const needsNewType = !currentEclipseInfo || 
                               (currentEclipseInfo.kind !== 'lunar' && !isUserJumped);
          
          if (needsNewType && !isUserJumped) {
            console.log('重新确定月食类型，原因：', {
              noInfo: !currentEclipseInfo,
              wrongKind: currentEclipseInfo && currentEclipseInfo.kind !== 'lunar',
              currentDay: days,
              bestDay: currentEclipseInfo ? currentEclipseInfo.bestDay : 'none'
            });
            currentEclipseInfo = determineEclipseType(days);
            console.log('确定月食类型：', currentEclipseInfo);
          } else {
            console.log('使用已存在的月食类型信息：', currentEclipseInfo.type, isUserJumped ? '(用户手动跳转，禁止重新计算)' : '');
          }
          
          // 使用预先确定的月食类型（整个过程保持不变）
          eclipseType = currentEclipseInfo.type;
          
          // 计算线性时间进度和遮挡强度
          const eclipseDuration = 3.0; // 月食持续时间约3天
          const eclipseStart = currentEclipseInfo.bestDay - eclipseDuration / 2;
          const eclipseEnd = currentEclipseInfo.bestDay + eclipseDuration / 2;
          
          if (days >= eclipseStart && days <= eclipseEnd) {
            // 线性时间进度（控制阴影位置）
            const timeProgress = (days - eclipseStart) / eclipseDuration;
            
            // 遮挡强度（基于对齐程度和交点距离）
            const alignmentFactor = Math.max(0, (alignmentProgress - ECLIPSE_THRESHOLDS.ALIGNMENT) / 30); // 0-1
            const nodeFactor = Math.max(0, 1 - nodeData.minDistanceFromNode / ECLIPSE_THRESHOLDS.PARTIAL); // 0-1
            const eclipseIntensity = alignmentFactor * nodeFactor;
            
            // 组合进度：时间进度控制位置，强度控制遮挡效果
            eclipseProgress = {
              timeProgress: timeProgress,
              intensity: eclipseIntensity,
              combined: timeProgress * Math.max(0.3, eclipseIntensity) // 确保最少30%的可见度
            };
          } else {
            eclipseProgress = {
              timeProgress: 0,
              intensity: 0,
              combined: 0
            };
          }
        }
        
        return {
          isEclipse: isEclipse,
          progress: typeof eclipseProgress === 'object' ? eclipseProgress : {
            timeProgress: eclipseProgress,
            intensity: eclipseProgress,
            combined: eclipseProgress
          },
          kind: eclipseKind, // 'solar' 或 'lunar'
          type: eclipseType, // 'total' 或 'partial'
          alignmentProgress: alignmentProgress,
          nodeDistance: nodeData.minDistanceFromNode
        };
      }
      
      // 如果不再满足日食/月食条件，但仍在日食模式，这是正常的
      // 因为日食过程中会有进度为0的时刻，不应该清除类型信息
      // 类型信息只在模式切换时清除
      
      return {
        isEclipse: false,
        progress: 0,
        kind: '',
        type: '',
        alignmentProgress: alignmentProgress,
        nodeDistance: nodeData.minDistanceFromNode
      };
    }

    /**
     * 开始2D日食/月食动画循环
     */
    function start2DEclipseAnimation() {
      function animate2DEclipse() {
        if (!isEclipseMode || !eclipse2DCtx) return;
        
        const syzygyData = calculateSyzygyProgress();
        const eclipseData = calculateEclipseProgress(syzygyData);
        
        if (eclipseData.isEclipse) {
          if (eclipseData.kind === 'solar') {
            draw2DSolarEclipse(eclipseData.progress, eclipseData.type);
          } else if (eclipseData.kind === 'lunar') {
            draw2DLunarEclipse(eclipseData.progress, eclipseData.type);
          }
        }
        
        eclipseAnimationId = requestAnimationFrame(animate2DEclipse);
      }
      
      animate2DEclipse();
    }

    /**
     * 调整2D日食/月食Canvas大小
     */
    function resize2DEclipse() {
      if (!eclipse2DCanvas) return;
      
      const container = document.getElementById('moonPhase3D');
      if (!container) return;
      
      const containerRect = container.getBoundingClientRect();
      if (containerRect.width === 0 || containerRect.height === 0) return;
      
      eclipse2DCanvas.width = containerRect.width;
      eclipse2DCanvas.height = containerRect.height;
    }
    
    // 初始化3D月相场景（延迟执行，确保DOM加载完成）
    setTimeout(() => {
      if (document.getElementById('moonPhase3D') && pipContainer.style.display !== 'none') {
        init3DMoonPhase();
      }
    }, 500);

    function  stepSimulation(dayDelta, totalDaysFlag = false) {
      if(!totalDaysFlag){
          //日期更新
          days += dayDelta;
          dateCurrent = new Date(dateOrigin.getTime() + days * 24 * 60 * 60 * 1000);
          updateDate();
          // 天体转动
          sun.rotation.y += dayDelta * sunRotateAnglePerDay;
          earthOrbit.rotation.y += dayDelta * earthRevolveAnglePerDay;
          earthRotationGroup.rotation.z = 0;
          earthSphere.rotation.y += dayDelta * earthRotateAnglePerDay;
          earthRotationGroup.rotation.z = 0.41015;
          moonOrbit.rotation.y += dayDelta * (moonRevolveAnglePerDay);
          moonOrbitGroup.rotation.y += dayDelta * moonOrbitPrecessionPerDay;
          moon.rotation.y += 0;
      }
      else{
          days = dayDelta;
          dateCurrent = new Date(dateOrigin.getTime() + days * 24 * 60 * 60 * 1000);
          updateDate();
          // 天体转动
          sun.rotation.y = days * sunRotateAnglePerDay;
          earthOrbit.rotation.y = days * earthRevolveAnglePerDay;
          earthRotationGroup.rotation.z = 0;
          earthSphere.rotation.y = days * earthRotateAnglePerDay;
          earthRotationGroup.rotation.z = 0.41015;
          moonOrbit.rotation.y = days * (moonRevolveAnglePerDay);
          moonOrbitGroup.rotation.y = days * moonOrbitPrecessionPerDay;
      }
      
      // 更新月相显示（只在时间变化时更新）
      updateMoonPhaseDisplayOptimized();
    }

    /* * * * * * * * * * * *
     * ui界面和交互函数
     * * * * * * * * * * * */
    //事件绑定
    controlBtn.addEventListener('click', switchControlPanel);
    controlPanel.addEventListener('mouseenter', () => { 
      mouseOnPanel = true;
    });
    controlPanel.addEventListener('mouseleave', () => {
      mouseOnPanel = false;
    });
    tabs.forEach(tab => { tab.addEventListener('click', switchTab); });
    earthTextureRadios.forEach(radio => { 
      radio.addEventListener('change', () => {
        if (radio.checked) changeEarthTexture(radio.value);
      }); 
    });
    sunTextureRadios.forEach(radio => { 
      radio.addEventListener('change', () => {
        if (radio.checked) changeSunTexture(radio.value);
      }); 
    });
    starlandRadios.forEach(radio => { 
      radio.addEventListener('change', () => {
        if (radio.checked) changeStarland(radio.value);
      }); 
    });
    speedInput.addEventListener('input', changeSpeedFactor);
    stopSwitch.addEventListener('change', changeStopSwitch);
    reserveSwitch.addEventListener('change', changeReserveSwitch);
    axisSwitch.addEventListener('change', changeAxisVisibility);
    prevPageBtn.addEventListener('click', prevHelpPage);
    nextPageBtn.addEventListener('click', nextHelpPage);
    moonNormalSwitch.addEventListener('change', changeMoonNormalVisibility);
    pipMinimize.addEventListener('click', togglePipMinimize);
    pipClose.addEventListener('click', togglePipVisibility);

    // 月球距离选择器事件监听
    const pipMoonDistanceSelect = document.getElementById('pipMoonDistanceSelect');
    if (pipMoonDistanceSelect) {
      pipMoonDistanceSelect.addEventListener('change', function() {
        // 当月球距离设置改变时，重新渲染日食画面
        if (isPipVisible) {
          updateMoonPhaseDisplay();
        }
      });
    }

    // 日食和月食按钮事件绑定
    document.getElementById('nextSolarEclipse').addEventListener('click', jumpToNextSolarEclipse);
    document.getElementById('nextLunarEclipse').addEventListener('click', jumpToNextLunarEclipse);
    document.getElementById('nextTotalSolarEclipse').addEventListener('click', jumpToNextTotalSolarEclipse);
    document.getElementById('nextPartialSolarEclipse').addEventListener('click', jumpToNextPartialSolarEclipse);
    document.getElementById('nextTotalLunarEclipse').addEventListener('click', jumpToNextTotalLunarEclipse);
    document.getElementById('nextPartialLunarEclipse').addEventListener('click', jumpToNextPartialLunarEclipse);

    
    // 画中画开关事件绑定
    PIPSwitch.addEventListener('change', function() {
      if (PIPSwitch.checked) {
        pipContainer.style.display = 'block';
        isPipVisible = true;
        // 异步初始化3D场景
        setTimeout(() => {
          if (init3DMoonPhase()) {
            // 直接更新月相显示，不需要初始化过渡参数
            updateMoonPhaseDisplay();
          } else {
            // 如果初始化失败，再尝试一次
            setTimeout(() => {
              if (init3DMoonPhase()) {
                updateMoonPhaseDisplay();
              } else {
                console.warn('3D月相场景初始化失败，请检查DOM结构');
              }
            }, 500);
          }
        }, 100);
      } else {
        pipContainer.style.display = 'none';
        isPipVisible = false;
        // 清理所有资源
        cleanup3DMoonPhase();
        cleanup2DEclipse();
        isEclipseMode = false;
      }
    });
    moonNodesSwitch.addEventListener('change', changeMoonNodesVisibility);
    
    // 窗口大小调整事件监听器
    window.addEventListener('resize', function() {
      // 调整主渲染器大小
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      
      // 调整3D月相渲染器大小
      resize3DMoonPhase();
      
      // 调整2D日食/月食Canvas大小
      resize2DEclipse();
    });
    
    //控制面板开关
    function switchControlPanel(){
      if (isControlPanelOpen) {
        controlPanel.style.width = '0';
        controlBtn.style.left = '24px';
        isControlPanelOpen = false;
      }
      else{
        controlPanel.style.width = '360px';
        controlBtn.style.left = '400px';
        isControlPanelOpen = true;
      }
    }

    //控制面板标签页切换
    function switchTab() {
      tabs.forEach(t => t.classList.remove('active'));
      panels.forEach(p => p.classList.remove('active'));
      this.classList.add('active');
      document.getElementById(this.dataset.tab).classList.add('active');
    }

    //修改地球纹理
    function changeEarthTexture(value) {
      if (value == "common-map"){
        earthMaterial.map = earthTextureCommon;
        earthMaterial.color = new THREE.Color(0xcccccc);
      }
      else if (value == "satellite-map"){
        earthMaterial.map = earthTextureSatellite;
        earthMaterial.color = new THREE.Color(0xcfe3fc);
      }
      else{
        earthMaterial.map = earthTextureBlue;
        earthMaterial.color = new THREE.Color(0x4488ff);
      }
    }

    //修改太阳纹理
    function changeSunTexture(value) {
      if (value == "true-surface"){
        sunMaterial.map = sunTextureTrue;
        sunMaterial.emissiveMap = sunTextureTrue;
      }
      else{
        sunMaterial.map = sunTextureOrange;
        sunMaterial.emissiveMap = sunTextureOrange;
      }
    }

    //修改星空显示
    function changeStarland(value) {
      if (value == "stars"){
        starfield.visible = true;
      }
      else{
        starfield.visible = false;
      }
    }

    //修改地轴显示
    function changeAxisVisibility() {
      earthAxisGroup.visible = axisSwitch.checked;
    }

    //修改月球轨道法向量显示
    function changeMoonNormalVisibility() {
      moonOrbitNormalGroup.visible = moonNormalSwitch.checked;
    }

    //修改黄白交点显示
    function changeMoonNodesVisibility() {
      ascendingNode.visible = moonNodesSwitch.checked;
      descendingNode.visible = moonNodesSwitch.checked;
    }

    //修改速度
    function changeSpeedFactor() {
      speedFactor = 2 ** speedInput.value;
      if (speedFactor < 1)
        speedFactor = speedFactor.toFixed(2);
      else
        speedFactor = speedFactor.toFixed(0);
      speedLabel.innerHTML = 'x' + speedFactor;
      toolSpeed.innerHTML = "<i>x" + speedFactor + "</i>";
      dashboardSpeed.innerHTML = speedFactor + 'day/s';
    }

    //暂停、运行
    function changeStopSwitch() {
      if (stopSwitch.checked){
        isPaused = true;
        toolPause.innerHTML = '<i class="fa fa-play"></i>';
      }
      else{
        isPaused = false;
        toolPause.innerHTML = '<i class="fa fa-pause"></i>';
      }
    }

    //倒退运行
    function changeReserveSwitch() {
      if (reserveSwitch.checked)
        isbackwards = true;
      else
        isbackwards = false;
    }

    //日期跳转By
    function dateJumpBy(value) { 
      dayDelta = value;
      stepSimulation(dayDelta);
    }

    //小工具条：暂停
    function clickOnToolPause() {
      stopSwitch.checked = !stopSwitch.checked;
      changeStopSwitch();
    }

    //小工具条：速度
    function clickOnToolSpeed(value) {
      if(speedFactor >= 1 && speedFactor < 4) 
        speedInput.value = 2;
      else if(speedFactor >= 4 && speedFactor < 16) 
        speedInput.value = 4;
      else if(speedFactor >= 16 && speedFactor < 64) 
        speedInput.value = 6;
      else
        speedInput.value = 0;
      changeSpeedFactor();
    }

    //小工具条：截图
    function clickOnToolScreenshot() {
      rendererLock = true;
      renderer.render(scene, camera);
      var imgData = renderer.domElement.toDataURL("image/png");
      rendererLock = false;
      var link = document.createElement('a');
      link.href = imgData;
      link.download = 'screenshot.png';
      link.click();
    }

    //帮助窗口相关响应
    function clickOnToolHelp() {
      modalMask.style.display = 'flex';
      jumpToHelpPage(0);
    }

    function closeHelpWindow() {
      modalMask.style.display = 'none';
    }

    function nextHelpPage() {
      if(currentHelpPage < 5)
        jumpToHelpPage(currentHelpPage + 1);
      else return;
    }

    function prevHelpPage() {
      if(currentHelpPage > 0)
        jumpToHelpPage(currentHelpPage - 1);
      else return;
    }

    function jumpToHelpPage(page) {
      if(page >= 0 && page <= 5) {
        currentHelpPage = page;
        helpPages.style.transform = 'translateX(' + (-page * 16.66) + '%)';
        pageSwitcherDots.forEach((dot) => {
          dot.classList.remove('active'); 
        })
        pageSwitcherDots[page].classList.add('active');
        prevPageBtn.style.opacity = page === 0 ? '0' : '1';
        nextPageBtn.style.opacity = page === 5 ? '0' : '1';
      }
    }

    //日期更新
    function updateDate() {
      // 计算沙罗周期进度
      var sarosProgress = ((days % sarosCurrent) / sarosCurrent * 100);
      if(sarosProgress < 0) sarosProgress = 100 + sarosProgress;
      dashboardSaros.innerHTML = sarosProgress.toFixed(2) + '%';
      
      // 计算并显示月相状态
      updateMoonPhaseDisplay();
      
    }

    //画中画最小化切换
    function togglePipMinimize() {
      isPipMinimized = !isPipMinimized;
      if (isPipMinimized) {
        pipContainer.classList.add('minimized');
        pipMinimize.innerHTML = '<i class="fa fa-plus"></i>';
        pipMinimize.title = '展开';
      } else {
        pipContainer.classList.remove('minimized');
        pipMinimize.innerHTML = '<i class="fa fa-minus"></i>';
        pipMinimize.title = '最小化';
      }
    }

    //画中画显示/隐藏切换
    function togglePipVisibility() {
      isPipVisible = !isPipVisible;
      pipContainer.style.display = isPipVisible ? 'block' : 'none';
      // 同步更新控制面板中的开关状态
      PIPSwitch.checked = isPipVisible;
      
      // 如果隐藏，清理所有资源
      if (!isPipVisible) {
        cleanup3DMoonPhase();
        cleanup2DEclipse();
        isEclipseMode = false;
      }
    }

      // 视角切换相关变量与函数
      const topViewRadio = document.getElementById('top-view');
      const sideViewRadio = document.getElementById('side-view');
      const view3DRadio = document.getElementById('3D-view');

      function switchToTopView() {
          isViewLocked = true;
          camera.position.set(0, 15, 0);
          camera.up.set(0, 0, -1);
          camera.lookAt(scene.position);
      }

      function switchToSideView() {
          isViewLocked = true;
          camera.position.set(15, 0, 0);
          camera.up.set(0, 1, 0);
          camera.lookAt(scene.position);
      }

      function switchTo3DView() {
          isViewLocked = false;
      }

      function clickOnToolView(){
        if (topViewRadio.checked) {
          switchToSideView();
          topViewRadio.checked = false;
          sideViewRadio.checked = true;
        }
        else if (sideViewRadio.checked) {
          switchTo3DView();
          sideViewRadio.checked = false;
          view3DRadio.checked = true;
        }
        else if (view3DRadio.checked) {
          switchToTopView();
          view3DRadio.checked = false;
          topViewRadio.checked = true;
        }
      }

      // 绑定按钮事件
      topViewRadio.addEventListener('change', () => {
          if (topViewRadio.checked) switchToTopView();
      });
      sideViewRadio.addEventListener('change', () => {
          if (sideViewRadio.checked) switchToSideView();
      });
      view3DRadio.addEventListener('change', () => {
          if (view3DRadio.checked) switchTo3DView();
      });

    
    /**
     * 计算日地月三天体对齐进度
     * 修正版：正确计算月球相对于日地连线的角度位置
     */
    function calculateSyzygyProgress() {
      // 获取当前天体角度位置
      const earthAngle = earthOrbit.rotation.y; // 地球绕太阳的角度
      const moonInOrbit = moonOrbit.rotation.y; // 月球在轨道内的角度（恒星坐标系）
      
      // 月相计算：直接使用月球相对地球的角度，忽略轨道进动的微小影响
      // 月球在太阳坐标系中的角度 = 地球角度 + 月球相对地球的角度
      const moonRelativeToEarth = moonInOrbit;
      
      // 计算月相角度：从地球看月球相对于太阳的角度
      // 关键修正：月相角度应该是月球相对地球背向太阳方向的角度
      // 当moonRelativeToEarth=0时，月球在地球"前方"（面向太阳侧），应该是满月（180°）
      // 当moonRelativeToEarth=π时，月球在地球"后方"（背离太阳侧），应该是新月（0°）
      let moonPhaseAngle = (moonRelativeToEarth + Math.PI) % (2 * Math.PI);
      if (moonPhaseAngle < 0) moonPhaseAngle += 2 * Math.PI;
      
      // 将角度标准化到 [0, π] 范围，用于计算对齐度
      let alignmentAngle = Math.abs(moonPhaseAngle);
      if (alignmentAngle > Math.PI) {
        alignmentAngle = 2 * Math.PI - alignmentAngle;
      }
      
      // 计算对齐进度
      // 新月或满月时对齐度最高(100%)，上弦下弦时最低(0%)
      let alignmentProgress;
      if (alignmentAngle <= Math.PI/2) {
        // 新月方向对齐
        alignmentProgress = (Math.PI/2 - alignmentAngle) / (Math.PI/2) * 100;
      } else {
        // 满月方向对齐
        alignmentProgress = (alignmentAngle - Math.PI/2) / (Math.PI/2) * 100;
      }
      
      // 判断月相和对齐类型
      let alignmentType = '';
      const phaseDegrees = moonPhaseAngle * 180 / Math.PI;
      
      // 检查是否接近黄白交点（日月食可能）
      const nodeData = calculateMoonNodePosition(days);
      const isNearNode = nodeData.isNearNode;
      
      // 使用预先确定的日食/月食类型，确保整个过程保持一致
      let effectiveEclipseType = 'none';
      if (currentEclipseInfo && isNearNode) {
        // 检查是否在当前日食/月食过程中（扩大时间范围）
        const timeFromBest = Math.abs(days - currentEclipseInfo.bestDay);
        if (timeFromBest <= 2.5) { // 在食甚前后2.5天内（覆盖完整的跳转范围）
          if (phaseDegrees < 20 || phaseDegrees > 340) {
            // 新月期间，使用预先确定的日食类型
            if (currentEclipseInfo.kind === 'solar') {
              effectiveEclipseType = currentEclipseInfo.type;
              console.log(`使用预设日食类型: ${effectiveEclipseType}, 距离食甚: ${timeFromBest.toFixed(1)}天`);
            }
          } else if (phaseDegrees > 160 && phaseDegrees < 200) {
            // 满月期间，使用预先确定的月食类型
            if (currentEclipseInfo.kind === 'lunar') {
              effectiveEclipseType = currentEclipseInfo.type;
              console.log(`使用预设月食类型: ${effectiveEclipseType}, 距离食甚: ${timeFromBest.toFixed(1)}天`);
            }
          }
        }
      }
      
      // 如果没有预先确定的类型，则使用实时计算的类型
      if (effectiveEclipseType === 'none') {
        effectiveEclipseType = nodeData.eclipseType;
        console.log(`使用实时计算类型: ${effectiveEclipseType}`);
      }

      if (phaseDegrees < 20 || phaseDegrees > 340) {
        // 新月期间，可能发生日食
        if (effectiveEclipseType === 'total') {
          alignmentType = '日全食型新月';
        } else if (effectiveEclipseType === 'partial') {
          alignmentType = '日偏食型新月';
        } else {
          alignmentType = '新月';
        }
      } else if (phaseDegrees > 160 && phaseDegrees < 200) {
        // 满月期间，可能发生月食
        if (effectiveEclipseType === 'total') {
          alignmentType = '月全食型满月';
        } else if (effectiveEclipseType === 'partial') {
          alignmentType = '月偏食型满月';
        } else {
          alignmentType = '满月';
        }
      } else if (phaseDegrees > 75 && phaseDegrees < 105) {
        alignmentType = '上弦月';
      } else if (phaseDegrees > 255 && phaseDegrees < 285) {
        alignmentType = '下弦月';
      } else if (phaseDegrees < 90) {
        alignmentType = '蛾眉月';
      } else if (phaseDegrees < 180) {
        alignmentType = '盈凸月';
      } else if (phaseDegrees < 270) {
        alignmentType = '亏凸月';
      } else {
        alignmentType = '残月';
      }
      
      return {
        progress: alignmentProgress,
        type: alignmentType,
        moonPhase: phaseDegrees,
        isNearEclipseNode: isNearNode,
        currentDate: dateCurrent.toLocaleString(),
        earthAngle: earthAngle * 180 / Math.PI,
        debugInfo: {
          moonInOrbit: moonInOrbit * 180 / Math.PI,
          relativeAngle: moonRelativeToEarth * 180 / Math.PI
        }
      };
    }
    
    /**
     * 计算指定日期的日地月三天体对齐进度
     * 基于天数计算，而不是从当前模型状态读取
     */
    function calculateSyzygyProgressForDay(daysSinceOrigin) {
      // 基于天数计算天体角度位置
      const earthAngle = daysSinceOrigin * earthRevolveAnglePerDay;
      const moonInOrbit = daysSinceOrigin * moonRevolveAnglePerDay;
      
      // 月相计算：直接使用月球相对地球的角度，忽略轨道进动的微小影响
      // 月球在太阳坐标系中的角度 = 地球角度 + 月球相对地球的角度
      const moonRelativeToEarth = moonInOrbit;
      
      // 计算月相角度：从地球看月球相对于太阳的角度
      // 关键修正：月相角度应该是月球相对地球背向太阳方向的角度
      // 当moonRelativeToEarth=0时，月球在地球"前方"（面向太阳侧），应该是满月（180°）
      // 当moonRelativeToEarth=π时，月球在地球"后方"（背离太阳侧），应该是新月（0°）
      let moonPhaseAngle = (moonRelativeToEarth + Math.PI) % (2 * Math.PI);
      if (moonPhaseAngle < 0) moonPhaseAngle += 2 * Math.PI;
      
      // 将角度标准化到 [0, π] 范围，用于计算对齐度
      let alignmentAngle = Math.abs(moonPhaseAngle);
      if (alignmentAngle > Math.PI) {
        alignmentAngle = 2 * Math.PI - alignmentAngle;
      }
      
      // 计算对齐进度
      // 新月或满月时对齐度最高(100%)，上弦下弦时最低(0%)
      let alignmentProgress;
      if (alignmentAngle <= Math.PI/2) {
        // 新月方向对齐
        alignmentProgress = (Math.PI/2 - alignmentAngle) / (Math.PI/2) * 100;
      } else {
        // 满月方向对齐
        alignmentProgress = (alignmentAngle - Math.PI/2) / (Math.PI/2) * 100;
      }
      
      // 判断月相和对齐类型
      let alignmentType = '';
      const phaseDegrees = moonPhaseAngle * 180 / Math.PI;
      
      // 检查是否接近黄白交点（日月食可能）
      const nodeData = calculateMoonNodePosition(daysSinceOrigin);
      const isNearNode = nodeData.isNearNode;
      
      // 使用预先确定的日食/月食类型，确保整个过程保持一致
      let effectiveEclipseType = 'none';
      if (currentEclipseInfo && isNearNode) {
        // 检查是否在当前日食/月食过程中（扩大时间范围）
        const timeFromBest = Math.abs(daysSinceOrigin - currentEclipseInfo.bestDay);
        if (timeFromBest <= 2.5) { // 在食甚前后2.5天内（覆盖完整的跳转范围）
          if (phaseDegrees < 20 || phaseDegrees > 340) {
            // 新月期间，使用预先确定的日食类型
            if (currentEclipseInfo.kind === 'solar') {
              effectiveEclipseType = currentEclipseInfo.type;
            }
          } else if (phaseDegrees > 160 && phaseDegrees < 200) {
            // 满月期间，使用预先确定的月食类型
            if (currentEclipseInfo.kind === 'lunar') {
              effectiveEclipseType = currentEclipseInfo.type;
            }
          }
        }
      }
      
      // 如果没有预先确定的类型，则使用实时计算的类型
      if (effectiveEclipseType === 'none') {
        effectiveEclipseType = nodeData.eclipseType;
      }

      if (phaseDegrees < 20 || phaseDegrees > 340) {
        // 新月期间，可能发生日食
        if (effectiveEclipseType === 'total') {
          alignmentType = '日全食型新月';
        } else if (effectiveEclipseType === 'partial') {
          alignmentType = '日偏食型新月';
        } else {
          alignmentType = '新月';
        }
      } else if (phaseDegrees > 160 && phaseDegrees < 200) {
        // 满月期间，可能发生月食
        if (effectiveEclipseType === 'total') {
          alignmentType = '月全食型满月';
        } else if (effectiveEclipseType === 'partial') {
          alignmentType = '月偏食型满月';
        } else {
          alignmentType = '满月';
        }
      } else if (phaseDegrees > 75 && phaseDegrees < 105) {
        alignmentType = '上弦月';
      } else if (phaseDegrees > 255 && phaseDegrees < 285) {
        alignmentType = '下弦月';
      } else if (phaseDegrees < 90) {
        alignmentType = '蛾眉月';
      } else if (phaseDegrees < 180) {
        alignmentType = '盈凸月';
      } else if (phaseDegrees < 270) {
        alignmentType = '亏凸月';
      } else {
        alignmentType = '残月';
      }
      
      // 创建测试日期
      const testDate = new Date(dateOrigin.getTime() + daysSinceOrigin * 24 * 60 * 60 * 1000);
      
      return {
        progress: alignmentProgress,
        type: alignmentType,
        moonPhase: phaseDegrees,
        isNearEclipseNode: isNearNode,
        currentDate: testDate.toLocaleString(),
        earthAngle: earthAngle * 180 / Math.PI,
        debugInfo: {
          moonInOrbit: moonInOrbit * 180 / Math.PI,
          relativeAngle: moonRelativeToEarth * 180 / Math.PI
        }
      };
    }

    /**
     * 更新月相状态显示（优化版本）
     */
    function updateMoonPhaseDisplayOptimized() {
      const syzygyData = calculateSyzygyProgress();
      
      // 更新仪表盘的月相显示
      dashboardMoonPhase.innerHTML = `${syzygyData.type}`;
      
      // 更新仪表盘的对齐程度显示
      dashboardAlignment.innerHTML = `${syzygyData.progress.toFixed(1)}%`;
      
      // 只在画中画可见时更新月相绘制
      if (isPipVisible && (pipRenderer || isEclipseMode)) {
        updatePipMoonPhase(syzygyData);
      }
      
              // 调试信息：检查日食/月食状态
        if (isPipVisible) {
          const eclipseData = calculateEclipseProgress(syzygyData);
          const progressValue = typeof eclipseData.progress === 'object' ? eclipseData.progress.combined : eclipseData.progress;
          if (eclipseData.isEclipse && progressValue > 0.05) {
            console.log(`日食/月食状态: ${eclipseData.kind === 'solar' ? '日食' : '月食'} ${eclipseData.type === 'total' ? '全食' : '偏食'} 进度: ${(progressValue * 100).toFixed(1)}%`);
          }
        }
        
        // 用户提示：首次使用时显示日食/月食功能说明
        if (isPipVisible && typeof window.eclipseHelpShown === 'undefined') {
          window.eclipseHelpShown = true;
          console.log('🌟 日食/月食功能已启用！');
          console.log('💡 使用提示：');
          console.log('  • 点击"下一次日食"或"下一次月食"按钮可快速跳转到日食/月食前2.5天');
          console.log('  • 这样可以观看完整的2D日食/月食动画过程（从正常状态到食甚再到结束）');
          console.log('  • 当对齐程度>75%且接近黄白交点时，画中画将自动切换为2D日食/月食动画');
          console.log('  • 日食发生在新月时，月食发生在满月时');
          console.log('  • 观察仪表盘的"对齐程度"指标来判断是否接近日食/月食');
          console.log('  • 可以调整速度来控制动画播放快慢');
        }
      
      return syzygyData;
    }
    
    /**
     * 更新画中画月相绘制（智能切换3D/2D模式）
     */
    function updatePipMoonPhase(syzygyData) {
      // 计算是否需要显示日食/月食动画
      const eclipseData = calculateEclipseProgress(syzygyData);
      
      // 判断是否应该切换到2D模式
      const progressValue = typeof eclipseData.progress === 'object' ? eclipseData.progress.combined : eclipseData.progress;
      const shouldUse2D = eclipseData.isEclipse && progressValue > 0.05;
      
      // 处理模式切换
      if (shouldUse2D && !isEclipseMode) {
        // 切换到2D模式
        console.log(`切换到2D ${eclipseData.kind === 'solar' ? '日食' : '月食'}模式`);
        
        // 隐藏3D渲染器
        if (pipRenderer && pipRenderer.domElement) {
          pipRenderer.domElement.style.display = 'none';
        }
        
        // 初始化2D Canvas
        if (init2DEclipse()) {
          isEclipseMode = true;
          start2DEclipseAnimation();
        }
        
      } else if (!shouldUse2D && isEclipseMode) {
        // 切换回3D模式
        console.log('切换回3D月相模式');
        
        // 清理2D Canvas
        cleanup2DEclipse();
        isEclipseMode = false;
        
        // 清除日食类型信息
        if (currentEclipseInfo) {
          console.log(`退出${currentEclipseInfo.kind === 'solar' ? '日食' : '月食'}模式，清除类型信息`);
          currentEclipseInfo = null;
        }
        
        // 显示3D渲染器
        if (pipRenderer && pipRenderer.domElement) {
          pipRenderer.domElement.style.display = 'block';
        }
        
        // 重新初始化3D场景（如果需要）
        if (!pipRenderer || !pipScene) {
          setTimeout(() => {
            if (init3DMoonPhase()) {
              updatePipMoonPhase(syzygyData);
            }
          }, 100);
          return;
        }
      }
      
      // 根据当前模式更新显示
      if (isEclipseMode) {
        
        // 2D动画会在自己的循环中更新
        
      } else {
        // 3D模式：更新3D月相显示
        const moonRelativeAngle = syzygyData.debugInfo.relativeAngle * Math.PI / 180; // 转换为弧度
        const phaseAngle = syzygyData.moonPhase * Math.PI / 180; // 月相角度
        const illumination = calculateIllumination(phaseAngle);
        
        // 直接更新3D月相，不使用平滑过渡以确保完全同步
        update3DMoonPhaseSync(moonRelativeAngle, illumination);
  
      }
      
    }
    
    /**
     * 更新月相状态显示（保留原函数用于手动调用）
     */
    function updateMoonPhaseDisplay() {
      return updateMoonPhaseDisplayOptimized();
    }
    
    /**
     * 根据月相角度计算照明程度（改进版 - 更自然的过渡）
     */
    function calculateIllumination(phaseAngle) {
      // 将角度标准化到 [0, 2π]
      let normalizedAngle = phaseAngle % (2 * Math.PI);
      if (normalizedAngle < 0) normalizedAngle += 2 * Math.PI;
      
      // 基础照明计算
      let baseIllumination = (1 - Math.cos(normalizedAngle)) / 2;
      
      // 应用平滑曲线，使过渡更自然
      // 使用 smoothstep 函数创建更平滑的过渡
      let smoothIllumination = smoothStep(0, 1, baseIllumination);
      
      // 在新月和满月附近增加一些非线性效果
      const newMoonFactor = Math.exp(-Math.pow(normalizedAngle / Math.PI, 2) * 3);
      const fullMoonFactor = Math.exp(-Math.pow((normalizedAngle - Math.PI) / Math.PI, 2) * 3);
      
      // 新月时减少亮度，满月时增加亮度
      if (normalizedAngle < Math.PI / 2 || normalizedAngle > 3 * Math.PI / 2) {
        smoothIllumination *= (1 - newMoonFactor * 0.3);
      } else if (normalizedAngle > Math.PI / 2 && normalizedAngle < 3 * Math.PI / 2) {
        smoothIllumination = Math.min(1, smoothIllumination * (1 + fullMoonFactor * 0.2));
      }
      
      return Math.max(0, Math.min(1, smoothIllumination));
    }
    
    /**
     * 平滑插值函数 - 创建更自然的过渡曲线
     */
    function smoothStep(edge0, edge1, x) {
      const t = Math.max(0, Math.min(1, (x - edge0) / (edge1 - edge0)));
      return t * t * (3 - 2 * t);
    }
    
    /* * * * * * * * * * * * * * * * * * * * * * * * *
     * 日食和月食判断功能
     * * * * * * * * * * * * * * * * * * * * * * * * */
    
    // 计算月球相对于黄白交点的位置
    function calculateMoonNodePosition(daysSinceOrigin) {
      // 月球在轨道上的位置角度（月球公转）
      const moonOrbitAngle = daysSinceOrigin * moonRevolveAnglePerDay;
      
      // 计算月球相对于交点的角度
      // 升交点位于角度π/2，降交点位于角度3π/2
      const angleFromAscendingNode = moonOrbitAngle - Math.PI/2;
      const angleFromDescendingNode = moonOrbitAngle - 3*Math.PI/2;
      
      // 标准化角度到[0, π]范围，取最小值
      const normalizeAngle = (angle) => {
        const normalized = ((angle % (2 * Math.PI)) + 2 * Math.PI) % (2 * Math.PI);
        return Math.min(normalized, 2 * Math.PI - normalized);
      };
      
      const distFromAscending = normalizeAngle(angleFromAscendingNode);
      const distFromDescending = normalizeAngle(angleFromDescendingNode);
      const minDistanceFromNode = Math.min(distFromAscending, distFromDescending);
      
      // 判断食相类型（使用统一标准）
      const eclipseType = determineEclipseTypeUnified(minDistanceFromNode);
      const isNearNode = eclipseType !== 'none';
      
      return {
        moonOrbitAngle: moonOrbitAngle,
        distanceFromAscendingNode: distFromAscending,
        distanceFromDescendingNode: distFromDescending,
        minDistanceFromNode: minDistanceFromNode,
        isNearNode: isNearNode,
        eclipseType: eclipseType, // 新增：食相类型
        nearAscendingNode: distFromAscending < distFromDescending
      };
    }
    

    // 寻找下一次日食的时间
    function findNextSolarEclipse(currentDays, maxSearchDays = 10000, eclipseType = 'any') {
      for (let i = 1; i < maxSearchDays; i++) {
        const testDay = currentDays + i;
        
        // 使用新的函数计算指定日期的对齐数据
        const syzygyData = calculateSyzygyProgressForDay(testDay);
        
        // 判断是否满足日食条件：
        // 1. 新月状态（月相0-20度或340-360度）
        // 2. 对齐程度高（>95%）
        // 3. 根据参数判断食相类型
        if ((syzygyData.moonPhase < 20 || syzygyData.moonPhase > 340) &&
            syzygyData.progress > ECLIPSE_THRESHOLDS.ALIGNMENT + 25) { // 95% 对齐度阈值
          
          const nodeData = calculateMoonNodePosition(testDay);
          
          // 根据参数判断食相类型
          if (eclipseType === 'any' && nodeData.isNearNode) {
            return { day: testDay, type: nodeData.eclipseType };
          } else if (eclipseType === 'total' && nodeData.eclipseType === 'total') {
            return { day: testDay, type: 'total' };
          } else if (eclipseType === 'partial' && nodeData.eclipseType === 'partial') {
            return { day: testDay, type: 'partial' };
          }
        }
      }
      
      return null; // 未找到
    }
    
    // 寻找下一次月食的时间
    function findNextLunarEclipse(currentDays, maxSearchDays = 10000, eclipseType = 'any') {
      for (let i = 1; i < maxSearchDays; i++) {
        const testDay = currentDays + i;
        
        // 使用新的函数计算指定日期的对齐数据
        const syzygyData = calculateSyzygyProgressForDay(testDay);
        
        // 判断是否满足月食条件：
        // 1. 满月状态（月相160-200度）
        // 2. 对齐程度高（>95%）
        // 3. 根据参数判断食相类型
        if (syzygyData.moonPhase > 160 && syzygyData.moonPhase < 200 &&
            syzygyData.progress > ECLIPSE_THRESHOLDS.ALIGNMENT + 25) { // 95% 对齐度阈值
          
          const nodeData = calculateMoonNodePosition(testDay);
          
          // 根据参数判断食相类型
          if (eclipseType === 'any' && nodeData.isNearNode) {
            console.log(`找到月食: 第${testDay.toFixed(2)}天, 类型: ${nodeData.eclipseType}, 交点距离: ${(nodeData.minDistanceFromNode * 180 / Math.PI).toFixed(1)}°`);
            return { day: testDay, type: nodeData.eclipseType };
          } else if (eclipseType === 'total' && nodeData.eclipseType === 'total') {
            console.log(`找到月全食: 第${testDay.toFixed(2)}天, 交点距离: ${(nodeData.minDistanceFromNode * 180 / Math.PI).toFixed(1)}°`);
            return { day: testDay, type: 'total' };
          } else if (eclipseType === 'partial' && nodeData.eclipseType === 'partial') {
            console.log(`找到月偏食: 第${testDay.toFixed(2)}天, 交点距离: ${(nodeData.minDistanceFromNode * 180 / Math.PI).toFixed(1)}°`);
            return { day: testDay, type: 'partial' };
          }
          
          // 调试信息：显示被跳过的候选
          if (eclipseType === 'total' && nodeData.eclipseType === 'partial') {
            console.log(`跳过月偏食候选: 第${testDay.toFixed(2)}天, 交点距离: ${(nodeData.minDistanceFromNode * 180 / Math.PI).toFixed(1)}°, 需要全食`);
          }
        }
      }
      
      return null; // 未找到
    }
    
    // 跳转到下一次日食
    function jumpToNextSolarEclipse() {
      console.log('正在搜索下一次日食...');
      
      // 显示加载提示
      const button = document.getElementById('nextSolarEclipse');
      const originalText = button.textContent;
      button.textContent = '搜索中...';
      button.disabled = true;
      
      // 使用 setTimeout 让UI有时间更新
      setTimeout(() => {
        const nextEclipse = findNextSolarEclipse(days, 10000); // 搜索接下来27年内
        
        if (nextEclipse !== null) {
          // 跳转到日食前2.5天，让用户看到完整的动画过程
          const targetDay = nextEclipse.day - 2.5;
          stepSimulation(targetDay, true);
          
          // 清除之前的类型信息，避免干扰
          currentEclipseInfo = null;
          
          // 设置日食类型信息
          currentEclipseInfo = {
            isEclipse: true,
            kind: 'solar',
            type: nextEclipse.type, // 直接使用查找到的类型
            bestDay: nextEclipse.day,
            bestAlignment: 100,
            nodeDistance: calculateMoonNodePosition(nextEclipse.day).minDistanceFromNode,
            userJumped: true // 标记为用户手动跳转，不允许重新计算
          };
          
          console.log('跳转到下一次日食前2.5天：', dateCurrent.toLocaleDateString());
          console.log('强制设置日食类型为：', currentEclipseInfo);
          
          // 获取日食高潮时的数据用于显示
          const syzygyData = calculateSyzygyProgressForDay(nextEclipse.day);
          
          // 根据食相类型显示不同消息
          const eclipseTypeText = nextEclipse.type === 'total' ? '日全食' : '日偏食';
          
          // 显示成功消息
          const eclipseDate = new Date(dateOrigin.getTime() + nextEclipse.day * 24 * 60 * 60 * 1000);
          const currentDate = new Date(dateOrigin.getTime() + targetDay * 24 * 60 * 60 * 1000);
          alert(`找到下一次${eclipseTypeText}！\n${eclipseTypeText}日期：${eclipseDate.toLocaleDateString()}\n当前跳转到：${currentDate.toLocaleDateString()}\n\n💡 提示：\n• 打开画中画可观看完整的日食动画过程\n• 可以调整速度来控制动画播放快慢\n• 使用快捷按钮±1月/±1年微调时间\n\n详细信息：\n月相：${syzygyData.type}\n对齐程度：${syzygyData.progress.toFixed(1)}%\n距离交点：${(calculateMoonNodePosition(nextEclipse.day).minDistanceFromNode * 180 / Math.PI).toFixed(1)}°`);
        } else {
          alert('在接下来的27年内未找到日食');
        }
        
        // 恢复按钮
        button.textContent = originalText;
        button.disabled = false;
      }, 100);
    }
    
    // 跳转到下一次月食
    function jumpToNextLunarEclipse() {
      console.log('正在搜索下一次月食...');
      
      // 显示加载提示
      const button = document.getElementById('nextLunarEclipse');
      const originalText = button.textContent;
      button.textContent = '搜索中...';
      button.disabled = true;
      
      // 使用 setTimeout 让UI有时间更新
      setTimeout(() => {
        const nextEclipse = findNextLunarEclipse(days, 10000); // 搜索接下来27年内
        
        if (nextEclipse !== null) {
          // 跳转到月食前2.5天，让用户看到完整的动画过程
          const targetDay = nextEclipse.day - 2.5;
          stepSimulation(targetDay, true);
          
          // 清除之前的类型信息，避免干扰
          currentEclipseInfo = null;
          
          // 设置月食类型信息
          currentEclipseInfo = {
            isEclipse: true,
            kind: 'lunar',
            type: nextEclipse.type, // 直接使用查找到的类型
            bestDay: nextEclipse.day,
            bestAlignment: 100,
            nodeDistance: calculateMoonNodePosition(nextEclipse.day).minDistanceFromNode,
            userJumped: true // 标记为用户手动跳转，不允许重新计算
          };
          
          console.log('跳转到下一次月食前2.5天：', dateCurrent.toLocaleDateString());
          console.log('强制设置月食类型为：', currentEclipseInfo);
          
          // 获取月食高潮时的数据用于显示
          const syzygyData = calculateSyzygyProgressForDay(nextEclipse.day);
          
          // 根据食相类型显示不同消息
          const eclipseTypeText = nextEclipse.type === 'total' ? '月全食' : '月偏食';
          
          // 显示成功消息
          const eclipseDate = new Date(dateOrigin.getTime() + nextEclipse.day * 24 * 60 * 60 * 1000);
          const currentDate = new Date(dateOrigin.getTime() + targetDay * 24 * 60 * 60 * 1000);
          alert(`找到下一次${eclipseTypeText}！\n${eclipseTypeText}日期：${eclipseDate.toLocaleDateString()}\n当前跳转到：${currentDate.toLocaleDateString()}\n\n💡 提示：\n• 打开画中画可观看完整的月食动画过程\n• 可以调整速度来控制动画播放快慢\n• 使用快捷按钮±1月/±1年微调时间\n\n详细信息：\n月相：${syzygyData.type}\n对齐程度：${syzygyData.progress.toFixed(1)}%\n距离交点：${(calculateMoonNodePosition(nextEclipse.day).minDistanceFromNode * 180 / Math.PI).toFixed(1)}°`);
        } else {
          alert('在接下来的27年内未找到月食');
        }
        
        // 恢复按钮
        button.textContent = originalText;
        button.disabled = false;
      }, 100);
    }

    // 跳转到下一次日全食
    function jumpToNextTotalSolarEclipse() {
      console.log('正在搜索下一次日全食...');
      
      const button = document.getElementById('nextTotalSolarEclipse');
      const originalText = button.textContent;
      button.textContent = '搜索中...';
      button.disabled = true;
      
      setTimeout(() => {
        const nextEclipse = findNextSolarEclipse(days, 10000, 'total');
        
        if (nextEclipse !== null) {
          // 跳转到日全食前2.5天，让用户看到完整的动画过程
          const targetDay = nextEclipse.day - 2.5;
          stepSimulation(targetDay, true);
          
          // 清除之前的类型信息，避免干扰
          currentEclipseInfo = null;
          
          // 强制设置日食类型信息，确保类型一致性
          currentEclipseInfo = {
            isEclipse: true,
            kind: 'solar',
            type: 'total', // 强制设为全食
            bestDay: nextEclipse.day,
            bestAlignment: 100,
            nodeDistance: calculateMoonNodePosition(nextEclipse.day).minDistanceFromNode,
            userJumped: true // 标记为用户手动跳转，不允许重新计算
          };
          
          console.log('跳转到下一次日全食前2.5天：', dateCurrent.toLocaleDateString());
          console.log('强制设置日食类型为：', currentEclipseInfo);
          
          const syzygyData = calculateSyzygyProgressForDay(nextEclipse.day);
          const eclipseDate = new Date(dateOrigin.getTime() + nextEclipse.day * 24 * 60 * 60 * 1000);
          const currentDate = new Date(dateOrigin.getTime() + targetDay * 24 * 60 * 60 * 1000);
          
          alert(`找到下一次日全食！\n日全食日期：${eclipseDate.toLocaleDateString()}\n当前跳转到：${currentDate.toLocaleDateString()}\n\n💡 提示：\n• 打开画中画可观看完整的日全食动画过程\n• 可以调整速度来控制动画播放快慢\n• 使用快捷按钮±1月/±1年微调时间\n\n详细信息：\n月相：${syzygyData.type}\n对齐程度：${syzygyData.progress.toFixed(1)}%\n距离交点：${(calculateMoonNodePosition(nextEclipse.day).minDistanceFromNode * 180 / Math.PI).toFixed(1)}°`);
        } else {
          alert('在接下来的27年内未找到日全食');
        }
        
        button.textContent = originalText;
        button.disabled = false;
      }, 100);
    }
    
    // 跳转到下一次日偏食
    function jumpToNextPartialSolarEclipse() {
      console.log('正在搜索下一次日偏食...');
      
      const button = document.getElementById('nextPartialSolarEclipse');
      const originalText = button.textContent;
      button.textContent = '搜索中...';
      button.disabled = true;
      
      setTimeout(() => {
        const nextEclipse = findNextSolarEclipse(days, 10000, 'partial');
        
        if (nextEclipse !== null) {
          // 跳转到日偏食前2.5天，让用户看到完整的动画过程
          const targetDay = nextEclipse.day - 2.5;
          stepSimulation(targetDay, true);
          
          // 清除之前的类型信息，避免干扰
          currentEclipseInfo = null;
          
          // 强制设置日食类型信息，确保类型一致性
          currentEclipseInfo = {
            isEclipse: true,
            kind: 'solar',
            type: 'partial', // 强制设为偏食
            bestDay: nextEclipse.day,
            bestAlignment: 100,
            nodeDistance: calculateMoonNodePosition(nextEclipse.day).minDistanceFromNode,
            userJumped: true // 标记为用户手动跳转，不允许重新计算
          };
          
          console.log('跳转到下一次日偏食前2.5天：', dateCurrent.toLocaleDateString());
          console.log('强制设置日食类型为：', currentEclipseInfo);
          
          const syzygyData = calculateSyzygyProgressForDay(nextEclipse.day);
          const eclipseDate = new Date(dateOrigin.getTime() + nextEclipse.day * 24 * 60 * 60 * 1000);
          const currentDate = new Date(dateOrigin.getTime() + targetDay * 24 * 60 * 60 * 1000);
          
          alert(`找到下一次日偏食！\n日偏食日期：${eclipseDate.toLocaleDateString()}\n当前跳转到：${currentDate.toLocaleDateString()}\n\n💡 提示：\n• 打开画中画可观看完整的日偏食动画过程\n• 可以调整速度来控制动画播放快慢\n• 使用快捷按钮±1月/±1年微调时间\n\n详细信息：\n月相：${syzygyData.type}\n对齐程度：${syzygyData.progress.toFixed(1)}%\n距离交点：${(calculateMoonNodePosition(nextEclipse.day).minDistanceFromNode * 180 / Math.PI).toFixed(1)}°`);
        } else {
          alert('在接下来的27年内未找到日偏食');
        }
        
        button.textContent = originalText;
        button.disabled = false;
      }, 100);
    }
    
    // 跳转到下一次月全食
    function jumpToNextTotalLunarEclipse() {
      console.log('正在搜索下一次月全食...');
      
      const button = document.getElementById('nextTotalLunarEclipse');
      const originalText = button.textContent;
      button.textContent = '搜索中...';
      button.disabled = true;
      
      setTimeout(() => {
        const nextEclipse = findNextLunarEclipse(days, 10000, 'total');
        
        if (nextEclipse !== null) {
          // 跳转到月全食前2.5天，让用户看到完整的动画过程
          const targetDay = nextEclipse.day - 2.5;
          stepSimulation(targetDay, true);
          
          // 清除之前的类型信息，避免干扰
          currentEclipseInfo = null;
          
          // 设置月食类型信息
          currentEclipseInfo = {
            isEclipse: true,
            kind: 'lunar',
            type: 'total', // 直接设置为月全食
            bestDay: nextEclipse.day,
            bestAlignment: 100,
            nodeDistance: calculateMoonNodePosition(nextEclipse.day).minDistanceFromNode,
            userJumped: true // 标记为用户手动跳转，不允许重新计算
          };
          
          console.log('跳转到下一次月全食前2.5天：', dateCurrent.toLocaleDateString());
          console.log('强制设置月食类型为：', currentEclipseInfo);
          
          const syzygyData = calculateSyzygyProgressForDay(nextEclipse.day);
          const eclipseDate = new Date(dateOrigin.getTime() + nextEclipse.day * 24 * 60 * 60 * 1000);
          const currentDate = new Date(dateOrigin.getTime() + targetDay * 24 * 60 * 60 * 1000);
          
          alert(`找到下一次月全食！\n月全食日期：${eclipseDate.toLocaleDateString()}\n当前跳转到：${currentDate.toLocaleDateString()}\n\n💡 提示：\n• 打开画中画可观看完整的月全食动画过程\n• 可以调整速度来控制动画播放快慢\n• 使用快捷按钮±1月/±1年微调时间\n\n详细信息：\n月相：${syzygyData.type}\n对齐程度：${syzygyData.progress.toFixed(1)}%\n距离交点：${(calculateMoonNodePosition(nextEclipse.day).minDistanceFromNode * 180 / Math.PI).toFixed(1)}°`);
        } else {
          alert('在接下来的27年内未找到月全食');
        }
        
        button.textContent = originalText;
        button.disabled = false;
      }, 100);
    }
    
    // 跳转到下一次月偏食
    function jumpToNextPartialLunarEclipse() {
      console.log('正在搜索下一次月偏食...');
      
      const button = document.getElementById('nextPartialLunarEclipse');
      const originalText = button.textContent;
      button.textContent = '搜索中...';
      button.disabled = true;
      
      setTimeout(() => {
        const nextEclipse = findNextLunarEclipse(days, 10000, 'partial');
        
        if (nextEclipse !== null) {
          // 跳转到月偏食前2.5天，让用户看到完整的动画过程
          const targetDay = nextEclipse.day - 2.5;
          stepSimulation(targetDay, true);
          
          // 清除之前的类型信息，避免干扰
          currentEclipseInfo = null;
          
          // 设置月食类型信息
          currentEclipseInfo = {
            isEclipse: true,
            kind: 'lunar',
            type: 'partial', // 直接设置为月偏食
            bestDay: nextEclipse.day,
            bestAlignment: 100,
            nodeDistance: calculateMoonNodePosition(nextEclipse.day).minDistanceFromNode,
            userJumped: true // 标记为用户手动跳转，不允许重新计算
          };
          
          console.log('跳转到下一次月偏食前2.5天：', dateCurrent.toLocaleDateString());
          console.log('强制设置月食类型为：', currentEclipseInfo);
          
          const syzygyData = calculateSyzygyProgressForDay(nextEclipse.day);
          const eclipseDate = new Date(dateOrigin.getTime() + nextEclipse.day * 24 * 60 * 60 * 1000);
          const currentDate = new Date(dateOrigin.getTime() + targetDay * 24 * 60 * 60 * 1000);
          
          alert(`找到下一次月偏食！\n月偏食日期：${eclipseDate.toLocaleDateString()}\n当前跳转到：${currentDate.toLocaleDateString()}\n\n💡 提示：\n• 打开画中画可观看完整的月偏食动画过程\n• 可以调整速度来控制动画播放快慢\n• 使用快捷按钮±1月/±1年微调时间\n\n详细信息：\n月相：${syzygyData.type}\n对齐程度：${syzygyData.progress.toFixed(1)}%\n距离交点：${(calculateMoonNodePosition(nextEclipse.day).minDistanceFromNode * 180 / Math.PI).toFixed(1)}°`);
        } else {
          alert('在接下来的27年内未找到月偏食');
        }
        
        button.textContent = originalText;
        button.disabled = false;
      }, 100);
    }

      </script>
  </body>
</html>