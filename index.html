<!DOCTYPE html>
<html lang="cn">
<head>
  <meta charset="UTF-8">
  <title>Solar System</title>
  <link rel="stylesheet" href="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/font-awesome/4.7.0/css/font-awesome.min.css">
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <!------ 标题 ------>
  <div id="title">
    <img src="https://cdn.picui.cn/vip/2025/07/11/6870e6590199f.png" alt="Solar System">
    <h1>Solar System Sim</h1>
  </div>

  <!------ 仪表盘区域 ------>
  <div id="dashboard">
    <div class="dashboard-item">
      <span class="db-label">当前日期</span>
      <span class="db-value" id="db-date">2000-1-1</span>
    </div>
    <div class="dashboard-divider"></div>
    <div class="dashboard-item">
      <span class="db-label">速度比例</span>
      <span class="db-value" id="db-speed">1d/s</span>
    </div>
    <div class="dashboard-divider"></div>
    <div class="dashboard-item">
      <span class="db-label">沙罗周期进度</span>
      <span class="db-value" id="db-saros">0%</span>
    </div>
    <div class="dashboard-divider"></div>
    <div class="dashboard-item">
      <span class="db-label">月相状态</span>
      <span class="db-value" id="db-moonphase">新月</span>
    </div>
    <div class="dashboard-divider"></div>
    <div class="dashboard-item">
      <span class="db-label">对齐程度</span>
      <span class="db-value" id="db-alignment">0%</span>
    </div>
  </div>

  <!------ 控制面板 ------>
  <button id="controlBtn" aria-label="打开/关闭控制面板">
    <span>≡</span>
  </button>
  <aside id="controlPanel">
    <!---- 标签页切换导航 ---->
    <nav id="tabs">
      <button class="tab active" data-tab="page1">
        <i class="fa fa-info-circle"></i>
        <span>信息</span>
      </button>
      <button class="tab" data-tab="page2">
        <i class="fa fa-eye"></i>
        <span>视图</span>
      </button>
      <button class="tab" data-tab="page3">
        <i class="fa fa-cog"></i>
        <span>参数</span>
      </button>
    </nav>
    <!---- 标签页内容 ---->
    <div id="panels">
      <!-- 标签页1：信息页 -->
      <div class="panel active" id="page1">
        <h3>基本信息</h3>
        <p>TODO: 放置关于天体科普（如天体参数、沙罗周期等）或者网页信息（如网页简介、开发者信息、功能描述等）的内容</p>
      </div>
      <!-- 标签页2：视图页 -->
      <div class="panel" id="page2">
        <!-- 控制块：相机视角 -->
        <div class="contorl-block" id="viewSettings">
          <h4>
            <span class="zh">相机视角</span>
            <span class="en">Camera View</span>
          </h4>
          <ul>
            <li>
              <input type="radio" name="view" id="top-view" value="top-view" checked hidden>
              <label for="top-view" class="view-label">
                <i class="fa fa-toggle-down"></i>
                <span>俯视图</span>
              </label>
            </li>
            <li>
              <input type="radio" name="view" id="side-view" value="side-view" hidden>
              <label for="side-view" class="view-label">
                <i class="fa fa-toggle-right"></i>
                <span>侧视图</span>
              </label>
            </li>
            <li>
              <input type="radio" name="view" id="3D-view" value="3D-view" hidden>
              <label for="3D-view" class="view-label">
                <i class="fa fa-cube"></i>
                <span>3D视图</span>
              </label>
            </li>
          </ul>
        </div>
        <hr>
        <!-- 控制块：贴图纹理 -->
        <div class="contorl-block" id="textureSettings">
          <h4>
            <span class="zh">贴图纹理</span>
            <span class="en">Surface Texture</span>
          </h4>
          <div id="earthTexture">
            <h5>地球贴图</h5>
            <ul>
              <li>
                <input type="radio" name="earth-texture" id="solid-blue" value="solid-blue" hidden>
                <label for="solid-blue" class="texture-label">
                  <i></i>
                  <span>纯蓝色</span>
                </label>
              </li>
              <li>
                <input type="radio" name="earth-texture" id="common-map" value="common-map" hidden>
                <label for="common-map" class="texture-label">
                  <i></i>
                  <span>世界区划地图</span>
                </label>
              </li>
              <li>
                <input type="radio" name="earth-texture" id="satellite-map" value="satellite-map" checked hidden>
                <label for="satellite-map" class="texture-label">
                  <i></i>
                  <span>卫星地图</span>
                </label>
              </li>
            </ul>
          </div>
          <div id="sunTexture">
            <h5>太阳贴图</h5>
            <ul>
              <li>
                <input type="radio" name="sun-texture" id="solid-orange" value="solid-orange" hidden>
                <label for="solid-orange" class="texture-label">
                  <i></i>
                  <span>纯橙色</span>
                </label>
              </li>
              <li>
                <input type="radio" name="sun-texture" id="true-surface" value="true-surface" checked hidden>
                <label for="true-surface" class="texture-label">
                  <i></i>
                  <span>真实表面</span>
                </label>
              </li>
            </ul>
          </div>
          <div id="starland">
            <h5>星空背景</h5>
            <ul>
              <li>
                <input type="radio" name="starland" id="solid-black" value="solid-black" hidden>
                <label for="solid-black" class="texture-label">
                  <i></i>
                  <span>纯黑</span>
                </label>
              </li>
              <li>
                <input type="radio" name="starland" id="stars" value="stars" checked hidden>
                <label for="stars" class="texture-label">
                  <i></i>
                  <span>繁星</span>
                </label>
              </li>
            </ul>
          </div>
          <div id="earthAxis">
            <h5>地轴显示</h5>
            <ul>
              <li>
                <input type="checkbox" id="axisSwitch" checked hidden>
                <label for="axisSwitch" class="texture-label">
                  <i></i>
                  <span>显示地轴</span>
                </label>
              </li>
            </ul>
          </div>
          <div id="moonOrbitNormal">
            <h5>月球轨道法向量</h5>
            <ul>
              <li>
                <input type="checkbox" id="moonNormalSwitch" checked hidden>
                <label for="moonNormalSwitch" class="texture-label">
                  <i></i>
                  <span>显示轨道法向量</span>
                </label>
              </li>
            </ul>
          </div>
        </div>
        <hr>
        <!-- 控制块：日月食画中画 -->
        <div class="contorl-block" id="PIPSettings">
          <h4>
            <span class="zh">日月食画中画</span>
            <span class="en">Solar/Moon Eclipse PIP</span>
          </h4>
          <ul><li>
            <input type="checkbox" id="PIPSwitch" hidden>
            <label for="PIPSwitch" class="PIP-label">
              <h5>画中画开关</h5>
              <i></i>
            </label>
          </li></ul>
          <ul><li>
            <label for="latitudePos">在地球上观测的地点</label>
            <select id="latitudePos" name="latitudePos">
              <option value="90">北极附近</option>
              <option value="45">北半球</option>
              <option value="0" selected>赤道</option>
              <option value="-45">南半球</option>
              <option value="-90">南极附近</option>
            </select>
          </li></ul>
        </div>
      <p>TODO: 或许有一些其他需要的配置</p>
      </div>
      <!-- 标签页3：参数调整 -->
      <div class="panel" id="page3">
        <!-- 控制块：速度控制 -->
        <div class="contorl-block" id="speedSettings">
          <h4>
            <span class="zh">速度控制</span>
            <span class="en">Speed Control</span>
          </h4>
          <ul><li>
            <h5>速度调节</h5>
            <input type="range" id="speedInput" min="-7" max="7" step="1" value="1">
            <label for="speedInput" class="speed-label" id="speedLabel">x1</label>
          </li></ul>
          <ul>
            <li>
              <h5>运动反向</h5>
              <input type="checkbox" id="reserveSwitch" hidden>
              <label for="reserveSwitch">
                <i></i>
              </label>
            </li>
            <li>
              <h5>运动暂停</h5>
              <input type="checkbox" id="stopSwitch" hidden>
              <label for="stopSwitch">
                <i></i>
              </label>
            </li>
          </ul>
        </div>
        <hr>
        <!-- 控制块：时间控制 -->
        <div class="contorl-block" id="timeSettings">
          <h4>
            <span class="zh">时间控制</span>
            <span class="en">Time Control</span>
          </h4>
          <ul><li>
            <h5>日期跳转</h5>
            <input type="date" id="dateInput">
            <button id="dateSubmit" onclick="onClickDateSubmit()"><i class="fa fa-check"></i></button>
          </li></ul>
          <ul>
            <h5>快捷选择</h5>
            <li>
              <button id="oneYearAgo" onclick="dateJumpBy(-365)">-1年</button>
              <button id="oneMonthAgo" onclick="dateJumpBy(-30)">-1月</button>
              <button id="oneMonthForward" onclick="dateJumpBy(30)">+1月</button>
              <button id="oneYearForward" onclick="dateJumpBy(365)">+1年</button>
            </li>
            <li>
              <button id="nextSolarEclipse">下一次日食</button>
              <button id="nextLunarEclipse">下一次月食</button>
            </li>
            <li>
              <button id="analyzeAlignment" onclick="showAlignmentAnalysis()">分析当前对齐</button>
            </li>
          </ul>
        </div>
        <hr>
        <!-- 控制块：天体尺寸 -->
        <div class="contorl-block" id="sizeSettings">
          <h4>
            <span class="zh">天体尺寸</span>
            <span class="en">Celestial size</span>
          </h4>
          <ul>
            <li>
              <input type="radio" name="size" id="suitable-size" value="suitable-size" checked hidden>
              
              <label for="suitable-size" class="size-label">
                <i class="fa fa-eye"></i>
                <span>适宜观察</span>
              </label>
            </li>
            <li>
              <input type="radio" name="size" id="true-size" value="true-size" hidden>
              <label for="true-size" class="size-label">
                <i class="fa fa-bullseye"></i>
                <span>真实大小</span>
              </label>
            </li>
          </ul>
        </div>
        <hr>
        <p>TODO: 或许有一些其他需要的配置</p>
      </div>
    </div>
  </aside>

  <!------ 画中画UI框 ------>
  <div id="pipContainer" style="display: none;">
    <div id="pipHeader">
      <div class="pip-title">
        <i class="fa fa-video-camera"></i>
        <span>日月食观测</span>
      </div>
      <div class="pip-controls">
        <button class="pip-btn" id="pipMinimize" title="最小化">
          <i class="fa fa-minus"></i>
        </button>
        <button class="pip-btn" id="pipClose" title="关闭">
          <i class="fa fa-times"></i>
        </button>
      </div>
    </div>
    <div id="pipContent">
      <div id="pipCanvas">
        <!-- 3D月相渲染容器 -->
        <div id="moonPhase3D"></div>
        <div class="pip-overlay">
          <div class="pip-info-text">
            <span id="pipLocationText">赤道观测</span>
            <span id="pipMoonPhaseText">新月</span>
          </div>
        </div>
      </div>
      <div id="pipInfo">
        <div class="pip-status">
          <span class="status-label">状态</span>
          <span class="status-value" id="pipStatus">待机中</span>
        </div>
        <div class="pip-location">
          <span class="location-label">观测点</span>
          <select id="pipLocationSelect">
            <option value="90">北极附近</option>
            <option value="45">北半球</option>
            <option value="0" selected>赤道</option>
            <option value="-45">南半球</option>
            <option value="-90">南极附近</option>
          </select>
        </div>
      </div>
    </div>
  </div>

  <!------ 小工具条 ------>
  <nav id="toolBar">
    <button class="tool-btn" id="toolPause" title="暂停" onclick="clickOnToolPause()">
      <i class="fa fa-pause"></i>
    </button>
    <button class="tool-btn" id="toolSpeed" title="速度" onclick="clickOnToolSpeed()">
      <i>x1</i>
    </button>
    <hr>
    <button class="tool-btn" id="toolView" title="切换视角">
      <i class="fa fa-eye"></i>
    </button>
    <button class="tool-btn" id="toolScreenshot" title="截图" onclick="clickOnToolScreenshot()">
      <i class="fa fa-camera"></i>
    </button>
    <hr>
    <button class="tool-btn" id="toolHelp" title="帮助">
      <i class="fa fa-question"></i>
    </button>
  </nav>

  <!--------------------------------------------->
  <!------------ 下面是JavaScript代码 ------------>
  <!--------------------------------------------->
  <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
  <script>
    /* * * * * * * * * *
     * 重要全局变量定义
     * * * * * * * * * */
    // 公共变量：控件
    const controlBtn = document.getElementById('controlBtn');
    const controlPanel = document.getElementById('controlPanel');
    const tabs = document.querySelectorAll('#tabs .tab');
    const panels = document.querySelectorAll('#panels .panel');
    const earthTextureRadios = document.querySelectorAll('#earthTexture input');
    const sunTextureRadios = document.querySelectorAll('#sunTexture input');
    const starlandRadios = document.querySelectorAll('#starland input');
    const axisSwitch = document.getElementById('axisSwitch');
    const moonNormalSwitch = document.getElementById('moonNormalSwitch');
    const speedInput = document.getElementById('speedInput');
    const speedLabel = document.getElementById('speedLabel');
    const reserveSwitch = document.getElementById('reserveSwitch');
    const stopSwitch = document.getElementById('stopSwitch');
    const dateInput = document.getElementById('dateInput');
    const dashboardDate = document.getElementById('db-date');
    const dashboardSpeed = document.getElementById('db-speed');
    const dashboardSaros = document.getElementById('db-saros');
    const dashboardMoonPhase = document.getElementById('db-moonphase');
    const dashboardAlignment = document.getElementById('db-alignment');
    const toolPause = document.getElementById('toolPause');
    const toolSpeed = document.getElementById('toolSpeed');
    const pipContainer = document.getElementById('pipContainer');
    const pipMinimize = document.getElementById('pipMinimize');
    const pipClose = document.getElementById('pipClose');
    const pipLocationSelect = document.getElementById('pipLocationSelect');
    const pipStatus = document.getElementById('pipStatus');
    const PIPSwitch = document.getElementById('PIPSwitch');
    const pipLocationText = document.getElementById('pipLocationText');
    const pipMoonPhaseText = document.getElementById('pipMoonPhaseText');
    
    // 3D月相相关变量
    let pipScene = null;
    let pipCamera = null;
    let pipRenderer = null;
    let pip3DMoon = null;
    let pipSunLight = null;
    let pipAmbientLight = null;
    let lastPhaseAngle = 0;
    let lastIllumination = 0;
    let phaseTransitionSpeed = 0.02; // 降低过渡速度，使变化更平滑
    let lastSunLightPosition = { x: 5, y: 0, z: 0 }; // 记录上次光源位置
    let isControlPanelOpen = false;
    let mouseDragging = false;
    let isPipMinimized = false;
    let isPipVisible = false;

    // 公共变量：天体和运动参数
    const frameRate = 60; //动画帧数
    const sunRotateAnglePerDay = 0.228729; //太阳每天自转的角度
    const earthRevolveAnglePerDay = 0.017202; //地球每天公转的角度（弧度）
    const earthRotateAnglePerDay = 6.283185; //地球每天自转的角度
    const moonRevolveAnglePerDay = 0.229985; //月球每天公转的角度(恒星坐标系)
    const moonRotateAnglePerDay = 0.229985; //月球每天自转的角度
    // 月球轨道进动：2π / (18.6年 × 365.25天) = 2π / 6793天 ≈ 0.000924
    const moonOrbitPrecessionPerDay = -0.000924; //月球轨道进动角速度（约18.6年一周期，逆行）
    const dateOrigin = new Date(2022, 11, 8); //日期原点（日地月共线，月球黄纬约为0）
    let dateCurrent = new Date(dateOrigin); //当前日期
    let days = 0;             //经历天数（当前日期与原点相差天数）
    const sarosCurrent = 6585.32; //沙罗周期：6585.32天
    let speedFactor = 1;      //速度因子
    let isPaused = false;     //暂停
    let isbackwards = false;  //倒退

    // 公共变量：场景、相机、渲染器、纹理
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.z = 10;
    const renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.body.appendChild(renderer.domElement);
    let rendererLock = false;    //渲染器锁
    const textureLoader = new THREE.TextureLoader();
    const sunTextureTrue = textureLoader.load('https://cdn.jsdelivr.net/gh/isXSong/FigureBed/SolarSystem/sun.jpg');
    const sunTextureOrange = textureLoader.load('https://cdn.jsdelivr.net/gh/isXSong/FigureBed/SolarSystem/orange.jpg');
    const earthTextureSatellite = textureLoader.load('https://cdn.jsdelivr.net/gh/isXSong/FigureBed/SolarSystem/earth-sate.jpg');
    const earthTextureCommon = textureLoader.load("https://cdn.jsdelivr.net/gh/isXSong/FigureBed/SolarSystem/earth-common.png");
    const earthTextureBlue = textureLoader.load("https://cdn.jsdelivr.net/gh/isXSong/FigureBed/SolarSystem/transparent.png");
    const moonTexture = textureLoader.load("https://cdn.jsdelivr.net/gh/isXSong/FigureBed/SolarSystem/moon.png");


    /* * * * * * * * * *
     * 3D场景初始化
     * 层次结构说明：
     * scene
     * ├── sun (太阳：自转)
     * ├── earthOrbit (地球轨道：绕太阳公转)
     * │   └── earthGroup (地球整体组合，位于轨道上)
     * │       ├── earthRotationGroup (地球自转组：只包含地球球体)
     * │       │   └── earthSphere (地球球体：跟随地球自转)
     * │       ├── moonOrbitGroup (月球轨道组：相对黄道面倾斜5.15°，Z轴倾斜)
     * │       │   └── moonOrbit (月球轨道：绕地球公转)
     * │       │       └── moon (月球：潮汐锁定，一面朝地球)
     * │       └── earthAxisGroup (地轴组：倾斜23.5°，Z轴倾斜，不自转)
     * │           ├── earthAxis (地轴线)
     * │           ├── northArrow (北极箭头)
     * │           └── southArrow (南极箭头)
     * ├── earthOrbitRing (地球轨道环)
     * └── starfield (星空背景)
     * 
     * 倾斜方向说明：
     * - 地轴倾斜23.5°，Z轴正方向倾斜(夏至时北极朝向太阳)
     * - 月球轨道倾斜-5.15°，Z轴负方向，与地轴倾斜方向相对
     * - 这种相对倾斜使得月球轨道与黄道面有交点，是日月食发生的关键
     * * * * * * * * * */
    // 设置背景
    scene.background = new THREE.Color(0x0d0f13);

    // 创建太阳
    const sunGeometry = new THREE.SphereGeometry(2, 32, 32);
    const sunMaterial = new THREE.MeshLambertMaterial({
      map: sunTextureTrue,
      color: 0xfcf083,
      emissive: 0xfcf083,
      emissiveMap: sunTextureTrue,
      emissiveIntensity: 0.8
    });
    const sun = new THREE.Mesh(sunGeometry, sunMaterial);
    scene.add(sun);

    // 光源：太阳光和环境光
    const sunLight = new THREE.PointLight(0xffffff, 100, 1000);
    sunLight.position.set(0, 0, 0);
    sunLight.castShadow = true;
    sunLight.shadow.mapSize.width = 2048;
    sunLight.shadow.mapSize.height = 2048;
    scene.add(sunLight);
    const ambientLight = new THREE.AmbientLight(0x101010, 30);
    scene.add(ambientLight);

    // 创建地球本体（只包含球体，不包含地轴）
    const earthGeometry = new THREE.SphereGeometry(0.5, 32, 32);
    const earthMaterial = new THREE.MeshPhongMaterial({ 
      color: 0xcfe3fc,
      shininess: 30,
      map: earthTextureSatellite,
    });
    earthMaterial.needUpdate = true;
    const earthSphere = new THREE.Mesh(earthGeometry, earthMaterial);
    earthSphere.castShadow = true;
    earthSphere.receiveShadow = true;

    // 创建地球自转组（只包含地球球体）
    const earthRotationGroup = new THREE.Object3D();
    earthRotationGroup.add(earthSphere);

    // 创建月球
    const moonGeometry = new THREE.SphereGeometry(0.15, 16, 16);
    const moonMaterial = new THREE.MeshPhongMaterial({ 
      color: 0xcccccc,
      map: moonTexture,
      shininess: 10
    });
    const moon = new THREE.Mesh(moonGeometry, moonMaterial);
    moon.castShadow = true;
    moon.receiveShadow = true;

    // 月球轨道组（绕地球公转）
    const moonOrbit = new THREE.Object3D();
    moonOrbit.add(moon);
    moon.position.x = 1.2;

    // 月球轨道倾斜组（相对黄道面倾斜5.15°）
    const moonOrbitGroup = new THREE.Object3D();
    moonOrbitGroup.add(moonOrbit);
    // 月球轨道相对黄道面倾斜5.15度，倾斜方向与地轴相关
    // 使用Z轴负方向倾斜，与地轴倾斜方向相对
    moonOrbitGroup.rotation.z = THREE.MathUtils.degToRad(-5.15);
    
    // 注意：月球轨道的进动
    // 1. moonOrbit.rotation.y 控制月球绕地球的公转（约27.3天一周期）
    // 2. moonOrbitGroup.rotation.y 控制月球轨道面的进动（约18.6年一周期）
    // 3. 月球轨道平面相对于黄道面倾斜约5.15度，倾斜方向与地轴相对
    // 4. 月球轨道平面的方向会缓慢进动，交点线在黄道面上旋转

    // 创建月球轨道法向量（显示轨道面的法线方向）
    const moonOrbitNormalGeometry = new THREE.CylinderGeometry(0.01, 0.01, 1.5, 8);
    const moonOrbitNormalMaterial = new THREE.MeshBasicMaterial({ 
      color: 0xff0088,
      transparent: true,
      opacity: 1.0
    });
    const moonOrbitNormal = new THREE.Mesh(moonOrbitNormalGeometry, moonOrbitNormalMaterial);

    // 创建法向量箭头（正方向）
    const normalArrowGeometry = new THREE.ConeGeometry(0.03, 0.12, 8);
    const normalArrowMaterial = new THREE.MeshBasicMaterial({ 
      color: 0xff0088,
      transparent: true,
      opacity: 1.0
    });
    const normalArrowUp = new THREE.Mesh(normalArrowGeometry, normalArrowMaterial);
    normalArrowUp.position.set(0, 0.81, 0);

    // 创建法向量箭头（负方向）
    const normalArrowDown = new THREE.Mesh(normalArrowGeometry, normalArrowMaterial);
    normalArrowDown.position.set(0, -0.81, 0);
    normalArrowDown.rotation.x = Math.PI;

    // 月球轨道法向量组（位于轨道中心，垂直于轨道平面）
    const moonOrbitNormalGroup = new THREE.Object3D();
    moonOrbitNormalGroup.add(moonOrbitNormal);
    moonOrbitNormalGroup.add(normalArrowUp);
    moonOrbitNormalGroup.add(normalArrowDown);
    
    // 将法向量添加到月球轨道组中，这样它会跟随轨道倾斜和进动
    moonOrbitGroup.add(moonOrbitNormalGroup);

    // 创建地轴（独立的组，不跟随地球自转）
    const axisGeometry = new THREE.CylinderGeometry(0.005, 0.005, 1.5, 8);
    const axisMaterial = new THREE.MeshBasicMaterial({ 
      color: 0xff4444,
      transparent: true,
      opacity: 0.8
    });
    const earthAxis = new THREE.Mesh(axisGeometry, axisMaterial);

    // 创建地轴箭头（北极端）
    const arrowGeometry = new THREE.ConeGeometry(0.02, 0.08, 8);
    const arrowMaterial = new THREE.MeshBasicMaterial({ 
      color: 0xff4444,
      transparent: true,
      opacity: 0.8
    });
    const northArrow = new THREE.Mesh(arrowGeometry, arrowMaterial);
    northArrow.position.set(0, 0.79, 0);

    // 创建地轴箭头（南极端）
    const southArrow = new THREE.Mesh(arrowGeometry, arrowMaterial);
    southArrow.position.set(0, -0.79, 0);
    southArrow.rotation.x = Math.PI;

    // 地轴组（包含轴线和箭头，有倾斜角度但不自转）
    const earthAxisGroup = new THREE.Object3D();
    earthAxisGroup.add(earthAxis);
    earthAxisGroup.add(northArrow);
    earthAxisGroup.add(southArrow);
    // 地轴倾斜23.5度
    earthAxisGroup.rotation.z = THREE.MathUtils.degToRad(23.5);

    // 地球整体组（包含自转组 + 月球轨道组 + 地轴组）
    const earthGroup = new THREE.Object3D();
    earthGroup.add(earthRotationGroup);
    earthGroup.add(moonOrbitGroup);
    earthGroup.add(earthAxisGroup);

    // 地球轨道组（地球整体绕太阳公转）
    const earthOrbit = new THREE.Object3D();
    earthOrbit.add(earthGroup);
    earthGroup.position.x = 5;
    scene.add(earthOrbit);

    // 地球、月球轨道环显示
    const earthOrbitGeometry = new THREE.RingGeometry(4.8, 5.2, 64);
    const earthOrbitMaterial = new THREE.MeshBasicMaterial({ 
      color: 0x444444, 
      side: THREE.DoubleSide,
      transparent: true,
      opacity: 0.3
    });
    const earthOrbitRing = new THREE.Mesh(earthOrbitGeometry, earthOrbitMaterial);
    earthOrbitRing.rotation.x = -Math.PI / 2;
    scene.add(earthOrbitRing);
    const moonOrbitGeometry = new THREE.RingGeometry(1.1, 1.3, 32);
    const moonOrbitMaterial = new THREE.MeshBasicMaterial({ 
      color: 0x888888, 
      side: THREE.DoubleSide,
      transparent: true,
      opacity: 0.4
    });
    const moonOrbitRing = new THREE.Mesh(moonOrbitGeometry, moonOrbitMaterial);
    moonOrbitRing.rotation.x = -Math.PI / 2;
    // 月球轨道环相对于月球轨道组的倾斜需要考虑到组本身的倾斜
    moonOrbitGroup.add(moonOrbitRing);

    //星空
    const starfield = createStarfield(scene, 2000, 800);
    function createStarfield(scene, count = 10000, radius = 1000) {
      const positions = new Float32Array(count * 3);
      for (let i = 0; i < count; i++) {
          const i3 = i * 3;
          const phi = Math.random() * Math.PI * 2; 
          const theta = Math.random() * Math.PI;   
          positions[i3] = radius * Math.sin(theta) * Math.cos(phi); 
          positions[i3 + 1] = radius * Math.sin(theta) * Math.sin(phi);
          positions[i3 + 2] = radius * Math.cos(theta);
      }
      const geometry = new THREE.BufferGeometry();
      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      const material = new THREE.PointsMaterial({
          color: 0xffffff,
          size: 2, 
          sizeAttenuation: true,
          transparent: true,   
          opacity: 0.8           
      });
      const starfield = new THREE.Points(geometry, material);
      starfield.renderOrder = -100;
      starfield.frustumCulled = false; 
      scene.add(starfield);
      return starfield;
    }

    // 鼠标控制
    let mouseX = 0, mouseY = 0;
    let targetX = 0, targetY = 0;
    const windowHalfX = window.innerWidth / 2;
    const windowHalfY = window.innerHeight / 2;
    
    document.addEventListener('mousedown', (event) => {
      mouseDragging = true;
    });
    
    document.addEventListener('mouseup', (event) => {
      mouseDragging = false;
    });
    
    document.addEventListener('mousemove', (event) => {
      if(!mouseDragging) return;
      mouseX = (event.clientX - windowHalfX) * 0.005;
      mouseY = (event.clientY - windowHalfY) * 0.005;
    });

    /* * * * * * * * * *
     * 动画更新
     * * * * * * * * * */
    function animate() {
      requestAnimationFrame(animate);
      // 运动和时间更新
      if(!isPaused){     
        var dayDelta = 1 / 60 * speedFactor;
        if(isbackwards) dayDelta = -dayDelta;
        stepSimulation(dayDelta);
      }
      
      // 相机控制
      targetX += (mouseX - targetX) * 0.05;
      targetY += (mouseY - targetY) * 0.05;
      camera.position.x = Math.sin(targetX) * 10;
      camera.position.y = targetY * 10;
      camera.position.z = Math.cos(targetX) * 10;
      camera.lookAt(scene.position);
    
      if(!rendererLock)  renderer.render(scene, camera);
    }
    
    animate();

    /* * * * * * * * * *
     * 3D月相渲染功能
     * * * * * * * * * */
    
    /**
     * 初始化3D月相场景
     */
    function init3DMoonPhase() {
      const container = document.getElementById('moonPhase3D');
      if (!container) {
        console.warn('3D月相容器未找到');
        return false;
      }
      
      try {
        // 创建场景
        pipScene = new THREE.Scene();
        // 背景颜色将通过 renderer.setClearColor 动态设置
        
        // 创建相机
        const containerRect = container.getBoundingClientRect();
        pipCamera = new THREE.PerspectiveCamera(
          50,
          containerRect.width / containerRect.height,
          0.1,
          100
        );
        pipCamera.position.set(0, 0, 3); // 地球视角：从Z轴正方向看月球
        pipCamera.lookAt(0, 0, 0); // 朝向月球中心
        
        // 创建渲染器
        pipRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
        pipRenderer.setSize(containerRect.width, containerRect.height);
        pipRenderer.shadowMap.enabled = true;
        pipRenderer.shadowMap.type = THREE.PCFSoftShadowMap;
        pipRenderer.outputEncoding = THREE.sRGBEncoding;
        pipRenderer.toneMapping = THREE.ACESFilmicToneMapping;
        pipRenderer.toneMappingExposure = 1.2;
        
        container.appendChild(pipRenderer.domElement);
        
        // 创建3D月球
        create3DMoon();
        
        // 创建光照
        create3DLighting();
        
        // 背景颜色将根据月相动态设置，不在此处固定
        
        // 开始渲染循环
        start3DMoonAnimation();
        
        // 直接使用同步方式初始化月相显示
        const syzygyData = calculateSyzygyProgress();
        updatePipMoonPhase(syzygyData);
        
        console.log('3D月相场景初始化成功');
        return true;
      } catch (error) {
        console.error('3D月相场景初始化失败:', error);
        return false;
      }
    }
    
    /**
     * 创建3D月球
     */
    function create3DMoon() {
      // 月球几何体
      const moonGeometry = new THREE.SphereGeometry(1, 64, 64);
      
      // 月球材质
      const moonMaterial = new THREE.MeshPhongMaterial({
        color: 0xcccccc,
        shininess: 5,
        transparent: false
      });
      
      // 如果有月球纹理，使用纹理
      if (typeof moonTexture !== 'undefined') {
        moonMaterial.map = moonTexture;
      }
      
      // 创建月球mesh
      pip3DMoon = new THREE.Mesh(moonGeometry, moonMaterial);
      pip3DMoon.castShadow = true;
      pip3DMoon.receiveShadow = true;
      
      // 潮汐锁定：月球始终以同一面朝向地球（观察者）
      // 设置初始朝向，确保月球表面特征始终面向观察者
      pip3DMoon.rotation.y = 0;
      pip3DMoon.rotation.x = 0;
      pip3DMoon.rotation.z = 0;
      
      // 添加法线贴图效果（模拟月球表面凹凸）
      const bumpTexture = createMoonBumpTexture();
      moonMaterial.bumpMap = bumpTexture;
      moonMaterial.bumpScale = 0.1;
      
      pipScene.add(pip3DMoon);
    }
    
    /**
     * 创建月球凹凸纹理
     */
    function createMoonBumpTexture() {
      const canvas = document.createElement('canvas');
      canvas.width = 512;
      canvas.height = 512;
      const ctx = canvas.getContext('2d');
      
      // 创建噪声纹理模拟月球表面
      const imageData = ctx.createImageData(512, 512);
      const data = imageData.data;
      
      for (let i = 0; i < data.length; i += 4) {
        const x = (i / 4) % 512;
        const y = Math.floor((i / 4) / 512);
        
        // 使用多层噪声创建月球表面效果
        let noise = 0;
        noise += Math.sin(x * 0.02) * Math.cos(y * 0.02) * 0.3;
        noise += Math.sin(x * 0.05) * Math.cos(y * 0.05) * 0.2;
        noise += Math.random() * 0.1;
        
        // 添加一些"环形山"
        const craters = [
          {x: 128, y: 128, radius: 30},
          {x: 300, y: 200, radius: 20},
          {x: 400, y: 350, radius: 25},
          {x: 150, y: 400, radius: 15}
        ];
        
        craters.forEach(crater => {
          const dist = Math.sqrt((x - crater.x) ** 2 + (y - crater.y) ** 2);
          if (dist < crater.radius) {
            noise -= (1 - dist / crater.radius) * 0.3;
          }
        });
        
        const value = Math.max(0, Math.min(255, (noise + 0.5) * 255));
        data[i] = value;     // R
        data[i + 1] = value; // G
        data[i + 2] = value; // B
        data[i + 3] = 255;   // A
      }
      
      ctx.putImageData(imageData, 0, 0);
      
      const texture = new THREE.CanvasTexture(canvas);
      texture.wrapS = THREE.RepeatWrapping;
      texture.wrapT = THREE.RepeatWrapping;
      return texture;
    }
    
    /**
     * 创建3D光照系统
     */
    function create3DLighting() {
      // 主光源（太阳光）
      pipSunLight = new THREE.DirectionalLight(0xffffff, 2.5);
      pipSunLight.position.set(5, 0, 0);
      pipSunLight.castShadow = true;
      pipSunLight.shadow.mapSize.width = 1024;
      pipSunLight.shadow.mapSize.height = 1024;
      pipSunLight.shadow.camera.near = 0.1;
      pipSunLight.shadow.camera.far = 10;
      pipSunLight.shadow.camera.left = -2;
      pipSunLight.shadow.camera.right = 2;
      pipSunLight.shadow.camera.top = 2;
      pipSunLight.shadow.camera.bottom = -2;
      pipScene.add(pipSunLight);
      
      // 环境光（微弱，模拟宇宙中的散射光）
      pipAmbientLight = new THREE.AmbientLight(0x404060, 0.1);
      pipScene.add(pipAmbientLight);
      
      // 添加一些点光源模拟地球反射光
      const earthLight = new THREE.PointLight(0x6699ff, 0.2, 10);
      earthLight.position.set(-3, 1, 2);
      pipScene.add(earthLight);
    }
    
    /**
     * 根据月相计算最佳观测时间的天空颜色 - 自然淡雅的天空渐变
     */
    function calculateSkyColor(moonRelativeAngle) {
      // 将角度标准化到 [0, 2π] 范围
      let normalizedAngle = ((moonRelativeAngle % (2 * Math.PI)) + 2 * Math.PI) % (2 * Math.PI);
      
      // 更自然、更淡雅的天空颜色
      const colors = {
        newMoon: { r: 18, g: 32, b: 47 },        // 新月：深蓝夜空
        firstQuarter: { r: 60, g: 50, b: 80 },   // 上弦月：淡紫黎明
        fullMoon: { r: 135, g: 206, b: 235 },   // 满月：经典天蓝色（白天）
        lastQuarter: { r: 255, g: 165, b: 79 }  // 下弦月：自然橙色晚霞
      };
      
      // 添加中间过渡色，让夜晚时间更长
      let targetColor;
      
      if (normalizedAngle < Math.PI / 6) {
        // 新月区域：深夜蓝（扩大夜晚范围）
        targetColor = colors.newMoon;
      } else if (normalizedAngle < Math.PI / 3) {
        // 深夜到黎明前
        const t = (normalizedAngle - Math.PI / 6) / (Math.PI / 6);
        const smoothT = t * t * (3 - 2 * t); // smoothstep
        targetColor = {
          r: Math.round(colors.newMoon.r + (colors.firstQuarter.r - colors.newMoon.r) * smoothT),
          g: Math.round(colors.newMoon.g + (colors.firstQuarter.g - colors.newMoon.g) * smoothT),
          b: Math.round(colors.newMoon.b + (colors.firstQuarter.b - colors.newMoon.b) * smoothT)
        };
      } else if (normalizedAngle < Math.PI / 2) {
        // 黎明到朝霞
        const t = (normalizedAngle - Math.PI / 3) / (Math.PI / 6);
        const smoothT = 0.5 * (1 + Math.sin(Math.PI * (t - 0.5))); // 正弦缓动
        // 过渡到淡朝霞色
        const dawnColor = { r: 173, g: 216, b: 230 }; // 淡蓝朝霞
        targetColor = {
          r: Math.round(colors.firstQuarter.r + (dawnColor.r - colors.firstQuarter.r) * smoothT),
          g: Math.round(colors.firstQuarter.g + (dawnColor.g - colors.firstQuarter.g) * smoothT),
          b: Math.round(colors.firstQuarter.b + (dawnColor.b - colors.firstQuarter.b) * smoothT)
        };
      } else if (normalizedAngle < 2 * Math.PI / 3) {
        // 朝霞到白天
        const t = (normalizedAngle - Math.PI / 2) / (Math.PI / 6);
        const smoothT = t * t * (3 - 2 * t);
        const dawnColor = { r: 173, g: 216, b: 230 };
        targetColor = {
          r: Math.round(dawnColor.r + (colors.fullMoon.r - dawnColor.r) * smoothT),
          g: Math.round(dawnColor.g + (colors.fullMoon.g - dawnColor.g) * smoothT),
          b: Math.round(dawnColor.b + (colors.fullMoon.b - dawnColor.b) * smoothT)
        };
      } else if (normalizedAngle < 4 * Math.PI / 3) {
        // 满月区域：明亮天蓝色（白天时间）
        targetColor = colors.fullMoon;
      } else if (normalizedAngle < 3 * Math.PI / 2) {
        // 白天到黄昏
        const t = (normalizedAngle - 4 * Math.PI / 3) / (Math.PI / 6);
        const smoothT = 0.5 * (1 + Math.sin(Math.PI * (t - 0.5)));
        // 过渡到温暖的黄昏橙色
        const goldenColor = { r: 255, g: 193, b: 128 }; // 温暖橙色
        targetColor = {
          r: Math.round(colors.fullMoon.r + (goldenColor.r - colors.fullMoon.r) * smoothT),
          g: Math.round(colors.fullMoon.g + (goldenColor.g - colors.fullMoon.g) * smoothT),
          b: Math.round(colors.fullMoon.b + (goldenColor.b - colors.fullMoon.b) * smoothT)
        };
      } else if (normalizedAngle < 5 * Math.PI / 3) {
        // 黄昏到日落
        const t = (normalizedAngle - 3 * Math.PI / 2) / (Math.PI / 6);
        const smoothT = t * t * (3 - 2 * t);
        const goldenColor = { r: 255, g: 193, b: 128 };
        targetColor = {
          r: Math.round(goldenColor.r + (colors.lastQuarter.r - goldenColor.r) * smoothT),
          g: Math.round(goldenColor.g + (colors.lastQuarter.g - goldenColor.g) * smoothT),
          b: Math.round(goldenColor.b + (colors.lastQuarter.b - goldenColor.b) * smoothT)
        };
      } else {
        // 日落到深夜（更长的夜晚过渡）
        const t = (normalizedAngle - 5 * Math.PI / 3) / (Math.PI / 3);
        const smoothT = 0.5 * (1 + Math.sin(Math.PI * (t - 0.5)));
        targetColor = {
          r: Math.round(colors.lastQuarter.r + (colors.newMoon.r - colors.lastQuarter.r) * smoothT),
          g: Math.round(colors.lastQuarter.g + (colors.newMoon.g - colors.lastQuarter.g) * smoothT),
          b: Math.round(colors.lastQuarter.b + (colors.newMoon.b - colors.lastQuarter.b) * smoothT)
        };
      }
      
      // 转换为16进制颜色
      const hexColor = (targetColor.r << 16) | (targetColor.g << 8) | targetColor.b;
      
      return hexColor;
    }
    
    /**
     * 颜色插值函数
     */
    function lerpColor(color1, color2, t) {
      const r1 = (color1 >> 16) & 0xff;
      const g1 = (color1 >> 8) & 0xff;
      const b1 = color1 & 0xff;
      
      const r2 = (color2 >> 16) & 0xff;
      const g2 = (color2 >> 8) & 0xff;
      const b2 = color2 & 0xff;
      
      const r = Math.round(r1 + (r2 - r1) * t);
      const g = Math.round(g1 + (g2 - g1) * t);
      const b = Math.round(b1 + (b2 - b1) * t);
      
      return (r << 16) | (g << 8) | b;
    }

    /**
     * 同步更新3D月相光照（直接匹配对齐程度，无过渡动画）
     */
    function update3DMoonPhaseSync(moonRelativeAngle, illumination) {
      if (!pipSunLight || !pip3DMoon) return;
      
      // 根据月相计算最佳观测时间的天空颜色
      const skyColor = calculateSkyColor(moonRelativeAngle);
      console.log(`同步函数 - 月相角度: ${(moonRelativeAngle * 180 / Math.PI).toFixed(1)}°, 天空颜色: #${skyColor.toString(16)}`);
      
      // 直接使用月球相对地球的角度，移除π/2修正
      const sunAngleFor3D = moonRelativeAngle;
      
      const sunDistance = 8;
      const targetSunX = Math.sin(sunAngleFor3D) * sunDistance;
      const targetSunY = 0; // 保持在赤道平面
      const targetSunZ = Math.cos(sunAngleFor3D) * sunDistance;
      
      // 更新背景颜色
      if (pipRenderer) {
        pipRenderer.setClearColor(skyColor, 1.0);
      }
      
      // 直接设置光源位置，不使用过渡动画
      pipSunLight.position.set(targetSunX, targetSunY, targetSunZ);
      pipSunLight.lookAt(0, 0, 0);
      
      // 直接设置光照强度
      const targetIntensity = 1.5 + illumination * 1.5;
      pipSunLight.intensity = targetIntensity;
      
      // 直接设置环境光
      const targetAmbient = 0.05 + illumination * 0.15;
      pipAmbientLight.intensity = targetAmbient;
      
      // 月球潮汐锁定 - 完全静止，不自转
      pip3DMoon.rotation.set(0, 0, 0);
      
      // 根据观测纬度调整相机Y位置（仰角）
      const latitude = parseFloat(pipLocationSelect.value) || 0;
      const latitudeOffset = Math.sin(latitude * Math.PI / 180) * 0.5;
      pipCamera.position.y = latitudeOffset;
      pipCamera.lookAt(0, 0, 0);
    }

    /**
     * 更新3D月相光照（根据太阳位置）- 保留用于初始化
     */
    function update3DMoonPhase(phaseAngle, illumination) {
      if (!pipSunLight || !pip3DMoon) return;
      
      // 根据原始月相角度计算逻辑：
      // phaseAngle来自 (moonRelativeToEarth + Math.PI) 的计算
      // 需要反推回moonRelativeToEarth来确定正确的光照方向
      
      // 反推月球相对地球的实际角度
      const moonRelativeAngle = phaseAngle - Math.PI;
      
      // 根据月相计算最佳观测时间的天空颜色
      const skyColor = calculateSkyColor(moonRelativeAngle);
      
      // 直接使用月球相对地球的角度，移除π/2修正
      const sunAngleFor3D = moonRelativeAngle;
      
      // 地球视角：相机在Z+方向，光源在XZ平面内旋转
      // 当moonRelativeAngle=0时（满月），光源从Z+方向照射
      // 当moonRelativeAngle=π时（新月），光源从Z-方向照射
      const sunDistance = 8;
      const targetSunX = Math.sin(sunAngleFor3D) * sunDistance;  // X轴变化
      const targetSunY = 0; // 保持在赤道平面
      const targetSunZ = Math.cos(sunAngleFor3D) * sunDistance;  // Z轴变化，主要方向
      
      // 更新背景颜色
      if (pipRenderer) {
        pipRenderer.setClearColor(skyColor, 1.0);
      }
      
      // 平滑过渡光源位置，避免瞬时变化 - 根据倍速调整
      const baseLightSpeed = 0.04;
      const lightTransitionSpeed = Math.min(0.5, baseLightSpeed * Math.sqrt(speedFactor));
      
      // 简化的平滑过渡，避免复杂的边界处理
      lastSunLightPosition.x += (targetSunX - lastSunLightPosition.x) * lightTransitionSpeed;
      lastSunLightPosition.y += (targetSunY - lastSunLightPosition.y) * lightTransitionSpeed;
      lastSunLightPosition.z += (targetSunZ - lastSunLightPosition.z) * lightTransitionSpeed;
      
      // 更新光源位置
      pipSunLight.position.set(lastSunLightPosition.x, lastSunLightPosition.y, lastSunLightPosition.z);
      pipSunLight.lookAt(0, 0, 0);
      
      // 根据照明程度调整光照强度
      const targetIntensity = 1.5 + illumination * 1.5;
      pipSunLight.intensity += (targetIntensity - pipSunLight.intensity) * 0.1;
      
      // 调整环境光
      const targetAmbient = 0.05 + illumination * 0.15;
      pipAmbientLight.intensity += (targetAmbient - pipAmbientLight.intensity) * 0.1;
      
      // 月球潮汐锁定 - 完全静止，不自转
      // 月球始终以同一面朝向观察者（地球）
      pip3DMoon.rotation.set(0, 0, 0);
      
      // 根据观测纬度调整相机Y位置（仰角）
      const latitude = parseFloat(pipLocationSelect.value) || 0;
      const latitudeOffset = Math.sin(latitude * Math.PI / 180) * 0.5;
      const targetCameraY = latitudeOffset;
      pipCamera.position.y += (targetCameraY - pipCamera.position.y) * 0.1;
      pipCamera.lookAt(0, 0, 0);
    }
    
    /**
     * 3D月相动画循环
     */
    function start3DMoonAnimation() {
      function animate3DMoon() {
        if (!pipRenderer || !pipScene || !pipCamera) return;
        
        requestAnimationFrame(animate3DMoon);
        
        // 只在画中画可见时渲染
        if (isPipVisible) {
          pipRenderer.render(pipScene, pipCamera);
        }
      }
      
      animate3DMoon();
    }
    
    /**
     * 调整3D月相渲染器大小
     */
    function resize3DMoonPhase() {
      if (!pipRenderer || !pipCamera) return;
      
      const container = document.getElementById('moonPhase3D');
      if (!container) return;
      
      const containerRect = container.getBoundingClientRect();
      if (containerRect.width === 0 || containerRect.height === 0) return;
      
      pipCamera.aspect = containerRect.width / containerRect.height;
      pipCamera.updateProjectionMatrix();
      pipRenderer.setSize(containerRect.width, containerRect.height);
    }
    
    /**
     * 清理3D月相资源
     */
    function cleanup3DMoonPhase() {
      if (pipRenderer) {
        const container = document.getElementById('moonPhase3D');
        if (container && pipRenderer.domElement.parentNode === container) {
          container.removeChild(pipRenderer.domElement);
        }
        pipRenderer.dispose();
        pipRenderer = null;
      }
      
      if (pipScene) {
        pipScene.clear();
        pipScene = null;
      }
      
      pipCamera = null;
      pip3DMoon = null;
      pipSunLight = null;
      pipAmbientLight = null;
    }
    
    // 初始化3D月相场景（延迟执行，确保DOM加载完成）
    setTimeout(() => {
      if (document.getElementById('moonPhase3D') && pipContainer.style.display !== 'none') {
        init3DMoonPhase();
      }
    }, 500);

    function  stepSimulation(dayDelta, totalDaysFlag = false) {
      if(!totalDaysFlag){
          //日期更新
          days += dayDelta;
          dateCurrent = new Date(dateOrigin.getTime() + days * 24 * 60 * 60 * 1000);
          updateDate();
          // 天体转动
          sun.rotation.y += dayDelta * sunRotateAnglePerDay;
          earthOrbit.rotation.y += dayDelta * earthRevolveAnglePerDay;
          earthRotationGroup.rotation.y += dayDelta * earthRotateAnglePerDay;
          moonOrbit.rotation.y += dayDelta * moonRevolveAnglePerDay;
          moonOrbitGroup.rotation.y += dayDelta * moonOrbitPrecessionPerDay;
          moon.rotation.y += 0;
      }
      else{
          days = dayDelta;
          dateCurrent = new Date(dateOrigin.getTime() + days * 24 * 60 * 60 * 1000);
          updateDate();
          // 天体转动
          sun.rotation.y = days * sunRotateAnglePerDay;
          earthOrbit.rotation.y = days * earthRevolveAnglePerDay;
          earthRotationGroup.rotation.y = days * earthRotateAnglePerDay;
          moonOrbit.rotation.y = days * moonRevolveAnglePerDay;
          moonOrbitGroup.rotation.y = days * moonOrbitPrecessionPerDay;
      }
      
      // 更新月相显示（只在时间变化时更新）
      updateMoonPhaseDisplayOptimized();
    }

    /* * * * * * * * * * * *
     * ui界面和交互函数
     * * * * * * * * * * * */
    //事件绑定
    controlBtn.addEventListener('click', switchControlPanel);
    tabs.forEach(tab => { tab.addEventListener('click', switchTab); });
    earthTextureRadios.forEach(radio => { 
      radio.addEventListener('change', () => {
        if (radio.checked) changeEarthTexture(radio.value);
      }); 
    });
    sunTextureRadios.forEach(radio => { 
      radio.addEventListener('change', () => {
        if (radio.checked) changeSunTexture(radio.value);
      }); 
    });
    starlandRadios.forEach(radio => { 
      radio.addEventListener('change', () => {
        if (radio.checked) changeStarland(radio.value);
      }); 
    });
    speedInput.addEventListener('input', changeSpeedFactor);
    stopSwitch.addEventListener('change', changeStopSwitch);
    reserveSwitch.addEventListener('change', changeReserveSwitch);
    axisSwitch.addEventListener('change', changeAxisVisibility);
    moonNormalSwitch.addEventListener('change', changeMoonNormalVisibility);
    pipMinimize.addEventListener('click', togglePipMinimize);
    pipClose.addEventListener('click', togglePipVisibility);
    pipLocationSelect.addEventListener('change', changePipLocation);
    
    // 主控制面板位置选择器同步
    const mainLocationSelect = document.getElementById('latitudePos');
    if (mainLocationSelect) {
      mainLocationSelect.addEventListener('change', function() {
        if (isPipVisible) {
          pipLocationSelect.value = mainLocationSelect.value;
          updateMoonPhaseDisplay();
        }
      });
    }
    PIPSwitch.addEventListener('change', function() {
      if (PIPSwitch.checked) {
        pipContainer.style.display = 'block';
        isPipVisible = true;
        // 异步初始化3D场景
        setTimeout(() => {
          if (init3DMoonPhase()) {
            // 直接更新月相显示，不需要初始化过渡参数
            updateMoonPhaseDisplay();
          } else {
            // 如果初始化失败，再尝试一次
            setTimeout(() => {
              if (init3DMoonPhase()) {
                updateMoonPhaseDisplay();
              } else {
                console.warn('3D月相场景初始化失败，请检查DOM结构');
              }
            }, 500);
          }
        }, 100);
      } else {
        pipContainer.style.display = 'none';
        isPipVisible = false;
        // 清理3D资源
        cleanup3DMoonPhase();
      }
    });

    //控制面板开关
    function switchControlPanel(){
      if (isControlPanelOpen) {
        controlPanel.style.width = '0';
        controlBtn.style.left = '24px';
        isControlPanelOpen = false;
      }
      else{
        controlPanel.style.width = '360px';
        controlBtn.style.left = '400px';
        isControlPanelOpen = true;
      }
    }

    //控制面板标签页切换
    function switchTab() {
      tabs.forEach(t => t.classList.remove('active'));
      panels.forEach(p => p.classList.remove('active'));
      this.classList.add('active');
      document.getElementById(this.dataset.tab).classList.add('active');
    }

    //修改地球纹理
    function changeEarthTexture(value) {
      if (value == "common-map"){
        earthMaterial.map = earthTextureCommon;
        earthMaterial.color = new THREE.Color(0xcccccc);
      }
      else if (value == "satellite-map"){
        earthMaterial.map = earthTextureSatellite;
        earthMaterial.color = new THREE.Color(0xcfe3fc);
      }
      else{
        earthMaterial.map = earthTextureBlue;
        earthMaterial.color = new THREE.Color(0x4488ff);
      }
    }

    //修改太阳纹理
    function changeSunTexture(value) {
      if (value == "true-surface"){
        sunMaterial.map = sunTextureTrue;
        sunMaterial.emissiveMap = sunTextureTrue;
      }
      else{
        sunMaterial.map = sunTextureOrange;
        sunMaterial.emissiveMap = sunTextureOrange;
      }
    }

    //修改星空显示
    function changeStarland(value) {
      if (value == "stars"){
        starfield.visible = true;
      }
      else{
        starfield.visible = false;
      }
    }

    //修改地轴显示
    function changeAxisVisibility() {
      earthAxisGroup.visible = axisSwitch.checked;
    }

    //修改月球轨道法向量显示
    function changeMoonNormalVisibility() {
      moonOrbitNormalGroup.visible = moonNormalSwitch.checked;
    }

    //修改速度
    function changeSpeedFactor() {
      speedFactor = 2 ** speedInput.value;
      if (speedFactor < 1)
        speedFactor = speedFactor.toFixed(2);
      else
        speedFactor = speedFactor.toFixed(0);
      speedLabel.innerHTML = 'x' + speedFactor;
      toolSpeed.innerHTML = "<i>x" + speedFactor + "</i>";
      dashboardSpeed.innerHTML = speedFactor + 'day/s';
    }

    //暂停、运行
    function changeStopSwitch() {
      if (stopSwitch.checked){
        isPaused = true;
        toolPause.innerHTML = '<i class="fa fa-play"></i>';
      }
      else{
        isPaused = false;
        toolPause.innerHTML = '<i class="fa fa-pause"></i>';
      }
    }

    //倒退运行
    function changeReserveSwitch() {
      if (reserveSwitch.checked)
        isbackwards = true;
      else
        isbackwards = false;
    }

    //日期跳转By
    function dateJumpBy(value) { 
      dayDelta = value;
      stepSimulation(dayDelta);
    }

    //日期跳转To
    function onClickDateSubmit(){
      var dayValue = dateInput.value;
      if (dayValue == '') return;
      var dateTarget = new Date(dayValue);
      var dayDelta = (dateTarget.getTime() - dateOrigin.getTime()) / (1000 * 60 * 60 * 24);
      if(Math.abs(dayDelta-days) < 1) return;
      stepSimulation(dayDelta, true);
    }

    //小工具条：暂停
    function clickOnToolPause() {
      stopSwitch.checked = !stopSwitch.checked;
      changeStopSwitch();
    }

    //小工具条：速度
    function clickOnToolSpeed(value) {
      if(speedFactor >= 1 && speedFactor < 4) 
        speedInput.value = 2;
      else if(speedFactor >= 4 && speedFactor < 16) 
        speedInput.value = 4;
      else if(speedFactor >= 16 && speedFactor < 64) 
        speedInput.value = 6;
      else
        speedInput.value = 0;
      changeSpeedFactor();
    }

    //小工具条：截图
    function clickOnToolScreenshot() {
      rendererLock = true;
      renderer.render(scene, camera);
      var imgData = renderer.domElement.toDataURL("image/png");
      rendererLock = false;
      var link = document.createElement('a');
      link.href = imgData;
      link.download = 'screenshot.png';
      link.click();
    }

    //日期更新
    function updateDate() {
      dashboardDate.innerHTML = dateCurrent.toLocaleString().split(' ')[0];
      
      // 计算沙罗周期进度
      var sarosProgress = ((days % sarosCurrent) / sarosCurrent * 100);
      if(sarosProgress < 0) sarosProgress = 100 + sarosProgress;
      dashboardSaros.innerHTML = sarosProgress.toFixed(2) + '%';
      
      // 计算并显示月相状态
      updateMoonPhaseDisplay();
      
      // 更新画中画状态
      updatePipStatus();
    }

    //画中画最小化切换
    function togglePipMinimize() {
      isPipMinimized = !isPipMinimized;
      if (isPipMinimized) {
        pipContainer.classList.add('minimized');
        pipMinimize.innerHTML = '<i class="fa fa-plus"></i>';
        pipMinimize.title = '展开';
      } else {
        pipContainer.classList.remove('minimized');
        pipMinimize.innerHTML = '<i class="fa fa-minus"></i>';
        pipMinimize.title = '最小化';
      }
    }

    //画中画显示/隐藏切换
    function togglePipVisibility() {
      isPipVisible = !isPipVisible;
      pipContainer.style.display = isPipVisible ? 'block' : 'none';
      // 同步更新控制面板中的开关状态
      PIPSwitch.checked = isPipVisible;
    }

    //改变画中画观测位置
    function changePipLocation() {
      const latitude = pipLocationSelect.value;
      // 同步更新控制面板中的位置选择器
      const mainLocationSelect = document.getElementById('latitudePos');
      if (mainLocationSelect) {
        mainLocationSelect.value = latitude;
      }
      
      // 更新画中画显示的位置信息
      updateMoonPhaseDisplay();
    }

    //更新画中画状态
    function updatePipStatus() {
      if (isPaused) {
        pipStatus.innerHTML = '已暂停';
        return;
      }
      
      // 使用精确的对齐计算
      const syzygyData = calculateSyzygyProgress();
      
      if (syzygyData.progress > 95) {
        pipStatus.innerHTML = `${syzygyData.type} (${syzygyData.progress.toFixed(1)}%)`;
      } else if (syzygyData.progress > 80) {
        pipStatus.innerHTML = `接近${syzygyData.type} (${syzygyData.progress.toFixed(1)}%)`;
      } else {
        pipStatus.innerHTML = `${syzygyData.type} (${syzygyData.progress.toFixed(1)}%)`;
      }
    }

    // 一些工具函数
    
    /**
     * 计算日地月三天体对齐进度
     * 修正版：正确计算月球相对于日地连线的角度位置
     */
    function calculateSyzygyProgress() {
      // 获取当前天体角度位置
      const earthAngle = earthOrbit.rotation.y; // 地球绕太阳的角度
      const moonOrbitPrecession = moonOrbitGroup.rotation.y; // 月球轨道进动
      const moonInOrbit = moonOrbit.rotation.y; // 月球在轨道内的角度（恒星坐标系）
      
      // 关键修正：月球相对于太阳的角度需要考虑地球的运动
      // 月球在太阳坐标系中的角度 = 地球角度 + 月球相对地球的角度
      const moonRelativeToEarth = moonInOrbit + moonOrbitPrecession;
      const moonAbsoluteAngle = earthAngle + moonRelativeToEarth;
      
      // 计算月相角度：从地球看月球相对于太阳的角度
      // 关键修正：月相角度应该是月球相对地球背向太阳方向的角度
      // 当moonRelativeToEarth=0时，月球在地球"前方"（面向太阳侧），应该是满月（180°）
      // 当moonRelativeToEarth=π时，月球在地球"后方"（背离太阳侧），应该是新月（0°）
      let moonPhaseAngle = (moonRelativeToEarth + Math.PI) % (2 * Math.PI);
      if (moonPhaseAngle < 0) moonPhaseAngle += 2 * Math.PI;
      
      // 将角度标准化到 [0, π] 范围，用于计算对齐度
      let alignmentAngle = Math.abs(moonPhaseAngle);
      if (alignmentAngle > Math.PI) {
        alignmentAngle = 2 * Math.PI - alignmentAngle;
      }
      
      // 计算对齐进度
      // 新月或满月时对齐度最高(100%)，上弦下弦时最低(0%)
      let alignmentProgress;
      if (alignmentAngle <= Math.PI/2) {
        // 新月方向对齐
        alignmentProgress = (Math.PI/2 - alignmentAngle) / (Math.PI/2) * 100;
      } else {
        // 满月方向对齐
        alignmentProgress = (alignmentAngle - Math.PI/2) / (Math.PI/2) * 100;
      }
      
      // 判断月相和对齐类型
      let alignmentType = '';
      const phaseDegrees = moonPhaseAngle * 180 / Math.PI;
      
      // 检查是否接近黄白交点（日月食可能）
      const isNearNode = Math.abs(Math.sin(moonOrbitPrecession)) < 0.087; // 约5度容差
      
      if (phaseDegrees < 15 || phaseDegrees > 345) {
        alignmentType = isNearNode ? '日食型新月' : '新月';
      } else if (phaseDegrees > 165 && phaseDegrees < 195) {
        alignmentType = isNearNode ? '月食型满月' : '满月';
      } else if (phaseDegrees > 75 && phaseDegrees < 105) {
        alignmentType = '上弦月';
      } else if (phaseDegrees > 255 && phaseDegrees < 285) {
        alignmentType = '下弦月';
      } else if (phaseDegrees < 90) {
        alignmentType = '蛾眉月';
      } else if (phaseDegrees < 180) {
        alignmentType = '盈凸月';
      } else if (phaseDegrees < 270) {
        alignmentType = '亏凸月';
      } else {
        alignmentType = '残月';
      }
      
      // 计算下次对齐时间
      const nextAlignment = calculateNextAlignment(moonPhaseAngle);
      
      return {
        progress: alignmentProgress,
        type: alignmentType,
        moonPhase: phaseDegrees,
        isNearEclipseNode: isNearNode,
        nextAlignment: nextAlignment,
        currentDate: dateCurrent.toLocaleString(),
        earthAngle: earthAngle * 180 / Math.PI,
        moonAngle: moonAbsoluteAngle * 180 / Math.PI,
        debugInfo: {
          moonInOrbit: moonInOrbit * 180 / Math.PI,
          orbitPrecession: moonOrbitPrecession * 180 / Math.PI,
          relativeAngle: moonRelativeToEarth * 180 / Math.PI
        }
      };
    }
    
    /**
     * 计算距离下次日地月完美对齐的天数
     * 修正版：基于正确的月球会合周期
     */
    function calculateNextAlignment(currentMoonPhase) {
      // 朔望月周期（会合周期）
      const synodicPeriod = 29.530588853; // 天
      
      // 当前月相角度（弧度转换为0-2π范围）
      const phaseRadians = currentMoonPhase;
      
      // 计算到下次新月的时间
      let daysToNewMoon;
      if (phaseRadians < 0.261799) { // 15度以内
        daysToNewMoon = (2 * Math.PI - phaseRadians) / (2 * Math.PI) * synodicPeriod;
      } else {
        daysToNewMoon = (2 * Math.PI - phaseRadians) / (2 * Math.PI) * synodicPeriod;
      }
      
      // 计算到下次满月的时间
      let daysToFullMoon;
      const fullMoonPhase = Math.PI; // 180度
      let phaseToFull = Math.abs(phaseRadians - fullMoonPhase);
      if (phaseToFull > Math.PI) {
        phaseToFull = 2 * Math.PI - phaseToFull;
      }
      
      if (phaseRadians < Math.PI) {
        daysToFullMoon = (Math.PI - phaseRadians) / (2 * Math.PI) * synodicPeriod;
      } else {
        daysToFullMoon = (3 * Math.PI - phaseRadians) / (2 * Math.PI) * synodicPeriod;
      }
      
      // 月球轨道交点周期约18.6年
      const nodePeriod = 18.6 * 365.25; // 天
      const currentNodePhase = (moonOrbitGroup.rotation.y % (2 * Math.PI));
      
      return {
        daysToNewMoon: Math.abs(daysToNewMoon),
        daysToFullMoon: Math.abs(daysToFullMoon),
        synodicPeriod: synodicPeriod,
        currentPhase: phaseRadians * 180 / Math.PI
      };
    }
    
    /**
     * 更新月相状态显示（优化版本）
     */
    function updateMoonPhaseDisplayOptimized() {
      const syzygyData = calculateSyzygyProgress();
      
      // 更新仪表盘的月相显示
      dashboardMoonPhase.innerHTML = `${syzygyData.type}`;
      
      // 更新仪表盘的对齐程度显示
      dashboardAlignment.innerHTML = `${syzygyData.progress.toFixed(1)}%`;
      
      // 只在画中画可见时更新月相绘制
      if (isPipVisible && pipRenderer) {
        updatePipMoonPhase(syzygyData);
      }
      
      return syzygyData;
    }
    
    /**
     * 更新画中画月相绘制（3D版本）- 直接同步对齐程度
     */
    function updatePipMoonPhase(syzygyData) {
      // 直接使用计算好的月球相对地球角度，确保与对齐程度完全同步
      const moonRelativeAngle = syzygyData.debugInfo.relativeAngle * Math.PI / 180; // 转换为弧度
      const phaseAngle = syzygyData.moonPhase * Math.PI / 180; // 月相角度
      const illumination = calculateIllumination(phaseAngle);
      
      // 直接更新3D月相，不使用平滑过渡以确保完全同步
      update3DMoonPhaseSync(moonRelativeAngle, illumination);
      
      // 更新文字信息
      if (pipMoonPhaseText) {
        pipMoonPhaseText.textContent = syzygyData.type;
      }
      
      // 更新观测位置信息
      if (pipLocationText) {
        const location = getLocationName(pipLocationSelect.value);
        pipLocationText.textContent = location + '观测';
      }
    }
    
    /**
     * 更新月相状态显示（保留原函数用于手动调用）
     */
    function updateMoonPhaseDisplay() {
      return updateMoonPhaseDisplayOptimized();
    }
    
    /**
     * 根据月相角度计算照明程度（改进版 - 更自然的过渡）
     */
    function calculateIllumination(phaseAngle) {
      // 将角度标准化到 [0, 2π]
      let normalizedAngle = phaseAngle % (2 * Math.PI);
      if (normalizedAngle < 0) normalizedAngle += 2 * Math.PI;
      
      // 基础照明计算
      let baseIllumination = (1 - Math.cos(normalizedAngle)) / 2;
      
      // 应用平滑曲线，使过渡更自然
      // 使用 smoothstep 函数创建更平滑的过渡
      let smoothIllumination = smoothStep(0, 1, baseIllumination);
      
      // 在新月和满月附近增加一些非线性效果
      const newMoonFactor = Math.exp(-Math.pow(normalizedAngle / Math.PI, 2) * 3);
      const fullMoonFactor = Math.exp(-Math.pow((normalizedAngle - Math.PI) / Math.PI, 2) * 3);
      
      // 新月时减少亮度，满月时增加亮度
      if (normalizedAngle < Math.PI / 2 || normalizedAngle > 3 * Math.PI / 2) {
        smoothIllumination *= (1 - newMoonFactor * 0.3);
      } else if (normalizedAngle > Math.PI / 2 && normalizedAngle < 3 * Math.PI / 2) {
        smoothIllumination = Math.min(1, smoothIllumination * (1 + fullMoonFactor * 0.2));
      }
      
      return Math.max(0, Math.min(1, smoothIllumination));
    }
    
    /**
     * 平滑插值函数 - 创建更自然的过渡曲线
     */
    function smoothStep(edge0, edge1, x) {
      const t = Math.max(0, Math.min(1, (x - edge0) / (edge1 - edge0)));
      return t * t * (3 - 2 * t);
    }
    
    /**
     * 获取观测位置名称
     */
    function getLocationName(value) {
      const locations = {
        '90': '北极',
        '45': '北半球',
        '0': '赤道',
        '-45': '南半球',
        '-90': '南极'
      };
      return locations[value] || '未知';
    }
    
    /**
     * 更新仪表盘显示对齐进度
     */
    function updateAlignmentDisplay() {
      const syzygyData = calculateSyzygyProgress();
      
      // 更新仪表盘显示 - 显示月相而不是对齐进度
      dashboardSaros.innerHTML = `${syzygyData.type} (${syzygyData.moonPhase.toFixed(1)}°)`;
      
      // 在控制台输出详细信息（调试用）
      console.log('=== 日地月对齐进度分析（修正版）===');
      console.log(`当前时间: ${syzygyData.currentDate}`);
      console.log(`月相: ${syzygyData.type}`);
      console.log(`月相角度: ${syzygyData.moonPhase.toFixed(2)}°`);
      console.log(`对齐进度: ${syzygyData.progress.toFixed(2)}%`);
      console.log(`是否接近交点: ${syzygyData.isNearEclipseNode ? '是' : '否'}`);
      console.log(`地球轨道角度: ${syzygyData.earthAngle.toFixed(2)}°`);
      console.log(`月球绝对角度: ${syzygyData.moonAngle.toFixed(2)}°`);
      console.log(`距下次新月: ${syzygyData.nextAlignment.daysToNewMoon.toFixed(1)}天`);
      console.log(`距下次满月: ${syzygyData.nextAlignment.daysToFullMoon.toFixed(1)}天`);
      console.log('调试信息:');
      console.log(`  月球轨道内角度: ${syzygyData.debugInfo.moonInOrbit.toFixed(2)}°`);
      console.log(`  轨道进动角度: ${syzygyData.debugInfo.orbitPrecession.toFixed(2)}°`);
      console.log(`  相对地球角度: ${syzygyData.debugInfo.relativeAngle.toFixed(2)}°`);
      console.log('================================');
      
      return syzygyData;
    }
    
    /**
     * 显示详细的对齐分析结果
     */
    function showAlignmentAnalysis() {
      const syzygyData = updateMoonPhaseDisplay();
      
      // 创建详细分析的弹窗或提示
      const analysisText = `
=== 日地月系统状态分析（修正版）===
时间: ${syzygyData.currentDate}

月相信息:
当前月相: ${syzygyData.type}
月相角度: ${syzygyData.moonPhase.toFixed(2)}°
对齐程度: ${syzygyData.progress.toFixed(1)}%

位置信息:
地球轨道角度: ${syzygyData.earthAngle.toFixed(2)}°
月球绝对角度: ${syzygyData.moonAngle.toFixed(2)}°
月球相对地球: ${syzygyData.debugInfo.relativeAngle.toFixed(2)}°

日月食信息:
接近黄白交点: ${syzygyData.isNearEclipseNode ? '是' : '否'}
日月食可能性: ${syzygyData.isNearEclipseNode && (syzygyData.progress > 80) ? '高' : '低'}

预测:
距下次新月: ${syzygyData.nextAlignment.daysToNewMoon.toFixed(1)}天
距下次满月: ${syzygyData.nextAlignment.daysToFullMoon.toFixed(1)}天

说明:
- 月相角度: 0°=新月, 90°=上弦, 180°=满月, 270°=下弦
- 对齐程度反映月球与日地连线的角度关系
- 日月食只在月球接近黄白交点时可能发生
      `;
      
      alert(analysisText);
    }

    // 窗口大小调整时的处理
    window.addEventListener('resize', function() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      
      // 重新调整3D月相渲染器
      if (pipRenderer && isPipVisible) {
        setTimeout(() => {
          resize3DMoonPhase();
        }, 100);
      }
    });
  </script>
</body>
</html>
